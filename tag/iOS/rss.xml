<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>iwantmyreal.name</title>
   
   <link>http://iwantmyreal.name</link>
   <description>so I can use google to index things I fixed and then promptly forgot</description>
   <language>en-uk</language>
   <managingEditor> Sam Davies</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Hands On with Adaptive Layout</title>
	  <link>/blog/2015/04/04/hands-on-with-adaptive-layout</link>
	  <author>Sam Davies</author>
	  <pubDate>2015-04-04T20:23:02+00:00</pubDate>
	  <guid>/blog/2015/04/04/hands-on-with-adaptive-layout</guid>
	  <description><![CDATA[
	     <p>iOS 8 supports five different screen sizes, and as a developer you should
support all of these. You have a choice: either create five distinct layouts,
or get with the cool kids and learn to love Auto Layout and Adaptive Layout.</p>

<p><img src="/images/2015-04-04-adaptive-layout.png" alt="Adaptive Layout" /></p>

<!-- more -->

<p>I presented a talk at <a href="http://cocoaconf.com/chicago-2015/home">CocoaConf Chicago</a>
that covered the basics of adaptive layout in interface builder, via a
live-building demo. We covered size classes, installable constraints,
installable views, adaptive fonts and adaptive images in a truly interactive
session.</p>

<p>Although the slides won’t mean a huge amount on their own, they’re available on
<a href="https://speakerdeck.com/sammyd/hands-on-with-adaptive-layout">SpeakerDeck</a> (and
below):</p>

<script async="" class="speakerdeck-embed" data-id="0526e941437545b2b3a4d98c6922fd85" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script>

<p>The sample project is available on GitHub at
<a href="https://github.com/sammyd/HandsOnAdaptiveLayout">github.com/sammyd/HandsOnAdaptiveLayout</a>.
If you’d like to review the four phases of the development of the adaptive
layout, you can check out the <code class="highlighter-rouge">StarterProject</code> tag, and then follow along with
the remaining commits.</p>

<p>Alone, these artefacts might not be be especially useful. If you’d like me to
visit you and present this talk, or a workshop based on the same concepts, then
please do get in touch - <a href="mailto:sam@visualputty.co.uk">sam@visualputty.co.uk</a>.</p>

<p>samx</p>

	  ]]></description>
	</item>

	<item>
	  <title>Levelling Up with iOS 8</title>
	  <link>/blog/2015/04/04/levelling-up-with-ios-8</link>
	  <author>Sam Davies</author>
	  <pubDate>2015-04-04T20:05:04+00:00</pubDate>
	  <guid>/blog/2015/04/04/levelling-up-with-ios-8</guid>
	  <description><![CDATA[
	     <p>Now that the winds from the iOS 8 storm have died down a little we can take a
step back and review what has happened. There are loads of great headline
features such as extensions and handoff, but what about the lesser-known
additions? Some of them are cool new features, whilst some of them will have
broken your existing app.</p>

<p><img src="/images/2015-04-04-levelling-up.png" alt="Levelling Up" /></p>

<!-- more -->

<p>I presented a talk at <a href="http://cocoaconf.com/chicago-2015/home">CocoaConf Chicago</a>
that took a look at the underdogs of iOS 8’s new features - first discovering
why your apps no longer function as you’d expect, before exploring a
few quick-wins to enhance your apps. It covered topics such as notification
actions, updates in XCTest, presentation of alerts &amp; popovers and more.</p>

<p>Although the slides won’t mean a huge amount on their own, they’re available on
<a href="https://speakerdeck.com/sammyd/levelling-up-with-ios-8">SpeakerDeck</a> (and
below):</p>

<script async="" class="speakerdeck-embed" data-id="535f6fba2f2e484e81ac34ddf5d09276" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script>

<p>The sample project is available on GitHub at
<a href="https://github.com/sammyd/iOS8-LevellingUp">github.com/sammyd/iOS8-LevellingUp</a>.</p>

<p>Alone, these artefacts might not be be especially useful. If you’d like me to
visit you and present this talk, or a workshop based on the same concepts, then
please do get in touch - <a href="mailto:sam@visualputty.co.uk">sam@visualputty.co.uk</a>.</p>

<p>samx</p>

	  ]]></description>
	</item>

	<item>
	  <title>NSSpain 2014</title>
	  <link>/blog/2014/09/19/nsspain-2014</link>
	  <author>Sam Davies</author>
	  <pubDate>2014-09-19T09:22:50+00:00</pubDate>
	  <guid>/blog/2014/09/19/nsspain-2014</guid>
	  <description><![CDATA[
	     <p>In September of 2014 I popped over from the UK to the far sunnier and more
pleasant city of Logroño in northern Spain for the second ever edition of
<a href="http://nsspain.com">NSSpain</a>.</p>

<p>Great conference in a really rather nice part of the world. Great talks, great
people and great wine :]</p>

<!-- more -->

<p>I presented a talk entitled <strong>To drawRect or not to drawRect</strong> - the slides for
which are available on SpeakerDeck at
<a href="https://speakerdeck.com/sammyd/to-drawrect-or-not-to-drawrect">speakerdeck.com/sammyd/to-drawrect-or-not-to-drawrect</a>
or you can see them below:</p>

<script async="" class="speakerdeck-embed" data-id="f3625e10996f01313e53426a9381af41" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script>

<p>The accompanying arrow-drawing project is available on Github at
<a href="https://github.com/sammyd/iOS-ArrowDrawing">github.com/sammyd/iOS-ArrowDrawing</a>.</p>

<p>If you’re interested in finding more about the different <code class="highlighter-rouge">CALayer</code> subclasses,
then check out the <strong>LayerCake</strong> project on github at
<a href="https://github.com/sammyd/iOS-LayerCake">github.com/sammyd/iOS-LayerCake</a>.</p>

<p>You should also check out <a href="http://shinobicontrols.com/iOS8DayByDay">iOS8: Day-by-Day</a>,
and <a href="https://leanpub.com/iOS7daybyday">iOS7: Day-by-Day</a>.</p>

<p>cheers!</p>

<p>sam
x</p>

	  ]]></description>
	</item>

	<item>
	  <title>Functional Reactive iOS: Talk</title>
	  <link>/blog/2014/07/04/functional-reactive-ios-talk</link>
	  <author>Sam Davies</author>
	  <pubDate>2014-07-04T09:20:31+00:00</pubDate>
	  <guid>/blog/2014/07/04/functional-reactive-ios-talk</guid>
	  <description><![CDATA[
	     <p>All too often we as developers spend our lives working out how to get data from
one part of our program to another. And then dealing with side effects associated
with shared state. These are a couple of the problems that the functional
reactive programming paradigm can help to solve.</p>

<p>In July 2014, I presented a talk at <a href="http://briste.ch/">#bristech</a> which looked
at what exactly functional reactive programming is, and how it can help you with
building your own applications.</p>

<!-- more -->

<p>The <strong>iOS</strong> part of the title is a bit of a misnomer - although my examples are
all from the world of CocoaTouch, there is not much which is specifically related
to <strong>ReactiveCocoa</strong>.</p>

<p>The slides are available:</p>

<script async="" class="speakerdeck-embed" data-id="7412d090e4fc0131e1bf4ab20097e045" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script>

<p>The code for the two sample projects is available on github:</p>

<ul>
  <li><a href="https://github.com/sammyd/RACTextFieldEventLog">github.com/sammyd/RACTextFieldEventLog</a></li>
  <li><a href="https://github.com/sammyd/ReactiveShinobi">github.com/sammyd/ReactiveShinobi</a> (if you are interested in the Swift
version, look at the <strong>swiftify</strong> or <strong>swiftify_with_pods</strong> branches)</li>
</ul>

<p>If you are interested in more technical detail about the project itself, then I
wrote a <a href="http://www.shinobicontrols.com/blog/posts/2014/06/24/reactiveshinobi-using-shinobicharts-with-reactivecocoa">blog post</a>
on the <a href="http://www.shinobicontrols.com/">ShinobiControls</a> blog,
explaining how to link <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>
with a ShinobiControls chart. I have also written an <a href="/blog/2014/07/02/reactivecocoa-2-dot-x-with-swift">article</a>
about how to use Swift with RAC 2.x, and the power that the type inference and
generics affords you.</p>

<p>I shall add the video to this page once it has arrived on the internets.</p>

<p>Feel free to gimme a shout on twitter if you have any questions / comments - I’m
<a href="https://twitter.com/iwantmyrealname">@iwantmyrealname</a>.</p>

<p>sam
x</p>

	  ]]></description>
	</item>

	<item>
	  <title>ReactiveCocoa 2.x with Swift</title>
	  <link>/blog/2014/07/02/reactivecocoa-2-dot-x-with-swift</link>
	  <author>Sam Davies</author>
	  <pubDate>2014-07-02T08:57:10+00:00</pubDate>
	  <guid>/blog/2014/07/02/reactivecocoa-2-dot-x-with-swift</guid>
	  <description><![CDATA[
	     <p>I recently wrote a blog post on the ShinobiControls blog about using
ReactiveCocoa with a ShinobiChart. It’s great - you should go and
<a href="http://www.shinobicontrols.com/blog/posts/2014/06/24/reactiveshinobi-using-shinobicharts-with-reactivecocoa">read it</a>.
I was also invited to give a talk at <a href="http://briste.ch/">#bristech</a> around the
same time, and thought that this blog post would make a really interesting topic.
The audience at #bristech is not an iOS audience. Not even mobile-focused. It’s
very much a mixed discipline event, with a heavy focus on javascript (lowest
common denominator etc.). Therefore I decided a general talk on functional
reactive programming, with ReactiveCocoa examples would be a great place to go.</p>

<p>One of the things non-Cocoa developers complain about is the somewhat alien
appearance of objective-C. Now, I don’t really think this is a valid complaint,
but in the interests of making my talk more accessible, I decided that if the
examples I gave were in Swift then fewer people would be frightened off.</p>

<p>And so begins the great-swiftening. I took the original project which accompanied
the previous blog post, and swiftified it. There were a few things I thought
might be useful to share. This post is the combination of those thoughts.</p>

<!--more-->

<h1 id="bridging-headers">Bridging Headers</h1>

<p>Bridging headers are part of the machinery which enables interaction between
swift and objective-C. They’re well-documented as part of Apple’s
<a href="https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html">interoperability guide</a>.
Essentially, there is a special header inside your project (specified with a
build setting) into which the objective-C headers for the classes you wish to use
with Swift should be collected.</p>

<p>The <strong>ReactiveWikiMonitor</strong> project uses 3 objective-C libraries:</p>

<ul>
  <li>ShinobiCharts</li>
  <li>SocketRocket</li>
  <li>ReactiveCocoa</li>
</ul>

<p>Therefore, the bridging header looks like this:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="cp">#import &lt;ShinobiCharts/ShinobiChart.h&gt;
#import &lt;SocketRocket/SRWebSocket.h&gt;
#import &lt;ReactiveCocoa/ReactiveCocoa.h&gt;</span></code></pre></figure>

<p>It’s actually that easy! I love how simple interoperability is at this level.
However, if you try and compile this (with your Podfile created correctly and
pods installed) then you’ll run in to some problems within the ReactiveCocoa
source.</p>

<h1 id="compiling-reactivecocoa-in-a-swift-project">Compiling ReactiveCocoa in a Swift Project</h1>

<p>If you try to build a project now, then the compiler will first attempt to compile
your pods - including ReactiveCocoa. Do it. You’ll see that it doesn’t work - you
get a compiler error around the methods <code class="highlighter-rouge">and</code>, <code class="highlighter-rouge">or</code> and <code class="highlighter-rouge">not</code> on <code class="highlighter-rouge">RACSignal+Operations</code>.
This is because of a compiler bug, which will hopefully be fixed in a future
release, but until then we can work around it by renaming those methods in the
ReactiveCocoa source.</p>

<p>Find the <strong>RACSignal+Operations.h</strong> file in the CocoaPods project, and rename
the aforementioned methods to <code class="highlighter-rouge">rac_and</code>, <code class="highlighter-rouge">rac_or</code> &amp; <code class="highlighter-rouge">rac_not</code>. You’ll have to
repeat this in the related implementation (<code class="highlighter-rouge">.m</code>) file as well. You can then find
all the places that use these methods, by attempting a build (there are only about
three places in the RAC source). Fixing each call by changing its name will work.
Note that it might also be possible to do this using Xcode’s refactor tools, but
I’ve not had the most success in the past.</p>

<p>Now your project will build, yay!</p>

<h1 id="using-generics-to-improve-syntax">Using generics to improve syntax</h1>

<p>One of the things I like about objective-C is the implicit casting available in
the arguments to blocks. By this I mean the following is the signature for a map
function in RAC (defined on <code class="highlighter-rouge">RACStream</code>):</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">map</span><span class="p">:(</span><span class="n">id</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">id</span> <span class="n">value</span><span class="p">))</span><span class="nv">block</span><span class="p">;</span></code></pre></figure>

<p>Which means that when creating a map stage in your pipeline, it would look like
this:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="nl">map:</span><span class="o">^</span><span class="n">id</span><span class="p">(</span><span class="n">id</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">return</span> <span class="n">value</span><span class="p">[</span><span class="s">@"content"</span><span class="p">];</span>
 <span class="p">}]</span></code></pre></figure>

<p>The block returns an <code class="highlighter-rouge">id</code>, and takes an <code class="highlighter-rouge">id</code> for the value parameter. This is so
that in objective-C you can build a functional pipeline which can process any
datatypes (since generics don’t exist). However, the syntax allows you to specify
(and therefore implicitly cast) these parameters, by defining your block like
this:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="nl">map:</span><span class="o">^</span><span class="n">NSString</span><span class="o">*</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">return</span> <span class="n">value</span><span class="p">[</span><span class="s">@"content"</span><span class="p">];</span>
 <span class="p">}]</span></code></pre></figure>

<p>Although not strictly necessary (since the compiler will allow you to call any
methods on an <code class="highlighter-rouge">id</code>), it just allows you to have additional type checking at
compile (and writing) time.</p>

<p>And now we move our attention to the world of Swift. The Swift equivalent to <code class="highlighter-rouge">id</code>
is <code class="highlighter-rouge">AnyObject</code>, so the map function now looks like this:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="o">.</span><span class="nf">map</span><span class="p">({</span> <span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">AnyObject</span><span class="o">!</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">AnyObject</span> <span class="k">in</span>
  <span class="k">return</span> <span class="n">value</span><span class="p">[</span><span class="s">"content"</span><span class="p">]</span>
<span class="p">})</span></code></pre></figure>

<p>If you attempt to build this code then (as of beta2) the compiler will crash.
In order to make this work you might think that the following would work:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="o">.</span><span class="nf">map</span><span class="p">({</span> <span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">NSDictionary</span><span class="o">!</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">NSString</span> <span class="k">in</span>
  <span class="k">return</span> <span class="n">value</span><span class="p">[</span><span class="s">"content"</span><span class="p">]</span>
<span class="p">})</span></code></pre></figure>

<p>However, Swift’s type system doesn’t like this (with a somewhat cryptic and
misplaced error message). Therefore you need to explicitly cast:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="o">.</span><span class="nf">map</span><span class="p">({</span> <span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">AnyObject</span><span class="o">!</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">AnyObject</span> <span class="k">in</span>
  <span class="k">if</span> <span class="k">let</span> <span class="nv">dict</span> <span class="o">=</span> <span class="n">value</span> <span class="k">as?</span> <span class="kt">NSDictionary</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">dict</span><span class="p">[</span><span class="s">"content"</span><span class="p">]</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="s">""</span>
<span class="p">})</span></code></pre></figure>

<p>You have to do this every time you want to call a <code class="highlighter-rouge">map</code> function, which in my
opinion is a little bit clumsy.</p>

<p>Which brings us to Swift’s generic system, and type inference.</p>

<h3 id="a-generic-version-of-map">A generic version of <code class="highlighter-rouge">map</code></h3>

<p>The syntax I’d like to use is:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="o">.</span><span class="nf">mapAs</span><span class="p">({</span> <span class="p">(</span><span class="nv">dict</span><span class="p">:</span> <span class="kt">NSDictionary</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">NSString</span> <span class="k">in</span>
  <span class="k">return</span> <span class="n">dict</span><span class="p">[</span><span class="s">"content"</span><span class="p">]</span> <span class="k">as</span> <span class="kt">NSString</span>
<span class="p">})</span></code></pre></figure>

<p>So how do we go about building this <code class="highlighter-rouge">mapAs()</code> extension method. Well, extending
a class in Swift is easy:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">extension</span> <span class="kt">RACStream</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">myNewMethod</span><span class="p">()</span> <span class="p">{</span>
      <span class="nf">println</span><span class="p">(</span><span class="s">"My new method"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>We’re going to create a generic <code class="highlighter-rouge">mapAs()</code> method, which includes the explicit
downcasting and the call to the underlying <code class="highlighter-rouge">map()</code> method:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="n">mapAs</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">,</span><span class="kt">U</span><span class="p">:</span> <span class="kt">AnyObject</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">block</span><span class="p">:</span> <span class="p">(</span><span class="kt">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">U</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">map</span><span class="p">({(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">AnyObject</span><span class="o">!</span><span class="p">)</span> <span class="k">in</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">casted</span> <span class="o">=</span> <span class="n">value</span> <span class="k">as?</span> <span class="kt">T</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nf">block</span><span class="p">(</span><span class="n">casted</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">nil</span>
  <span class="p">})</span>
<span class="p">}</span></code></pre></figure>

<p>This specifies that the <code class="highlighter-rouge">mapAs</code> method has 2 generic params - the input and output,
and that there is a requirement that the output be of type <code class="highlighter-rouge">AnyObject</code>. The closure
we pass to the <code class="highlighter-rouge">mapAs()</code> method takes the first generic type and returns the second.</p>

<p>All the <code class="highlighter-rouge">mapAs()</code> method does is call the underlying <code class="highlighter-rouge">map()</code> method, but performs
the downcasting as appropriate.</p>

<p>We can write a similar method for filter:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="n">filterAs</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">block</span><span class="p">:</span> <span class="p">(</span><span class="kt">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">filter</span><span class="p">({(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">AnyObject</span><span class="o">!</span><span class="p">)</span> <span class="k">in</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">casted</span> <span class="o">=</span> <span class="n">value</span> <span class="k">as?</span> <span class="kt">T</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nf">block</span><span class="p">(</span><span class="n">casted</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span>
  <span class="p">})</span>
<span class="p">}</span></code></pre></figure>

<p>This obviously can be extended to all the methods on <code class="highlighter-rouge">RACStream</code>, <code class="highlighter-rouge">RACSignal</code> etc.</p>

<p>I find that using these generic methods (combined with Swift’s type inference),
leads to a much more expressive pipeline:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">wsConnector</span><span class="o">.</span><span class="n">messages</span>
  <span class="o">.</span><span class="nf">filterAs</span><span class="p">({</span> <span class="p">(</span><span class="nv">dict</span><span class="p">:</span> <span class="kt">NSDictionary</span><span class="p">)</span> <span class="k">in</span>
      <span class="nf">return</span> <span class="p">(</span><span class="n">dict</span><span class="p">[</span><span class="s">"type"</span><span class="p">]</span> <span class="k">as</span> <span class="kt">NSString</span><span class="p">)</span><span class="o">.</span><span class="nf">isEqualToString</span><span class="p">(</span><span class="s">"unspecified"</span><span class="p">)</span>
    <span class="p">})</span>
  <span class="o">.</span><span class="nf">mapAs</span><span class="p">({</span> <span class="p">(</span><span class="nv">dict</span><span class="p">:</span> <span class="kt">NSDictionary</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">NSString</span> <span class="k">in</span>
    <span class="k">return</span> <span class="n">dict</span><span class="p">[</span><span class="s">"content"</span><span class="p">]</span> <span class="k">as</span> <span class="kt">NSString</span>
    <span class="p">})</span>
  <span class="o">.</span><span class="nf">deliverOn</span><span class="p">(</span><span class="kt">RACScheduler</span><span class="o">.</span><span class="nf">mainThreadScheduler</span><span class="p">())</span>
  <span class="o">.</span><span class="nf">subscribeNextAs</span><span class="p">({(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">NSString</span><span class="p">)</span> <span class="k">in</span>
    <span class="k">self</span><span class="o">.</span><span class="n">tickerLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">value</span>
    <span class="p">})</span></code></pre></figure>

<h1 id="conclusion">Conclusion</h1>

<p>This is very much an interim piece of work. We can expect RAC3 to be swift-focused,
and so these techniques won’t be required. However, they don’t just apply to RAC.
Using generics to simplify block arguments is especially helpful when interfacing
with objective-C which uses <code class="highlighter-rouge">id</code> as a type.</p>

<p>As ever, the code for this is available on the ‘swiftify’ branch of the
ReactiveShinobi project on my <a href="https://github.com/sammyd/ReactiveShinobi/tree/swiftify">github</a>.
If you don’t fancy having to fiddle with the ReactiveCocoa source once you’ve
pulled it down, there’s also a <a href="https://github.com/sammyd/ReactiveShinobi/tree/swiftify_with_pods">swiftify_with_pods</a>
branch, which includes the source code changes.</p>

<p>sam</p>

	  ]]></description>
	</item>

	<item>
	  <title>Email Address Validation in iOS</title>
	  <link>/blog/2013/07/28/email-address-validation-in-ios</link>
	  <author>Sam Davies</author>
	  <pubDate>2013-07-28T14:36:00+00:00</pubDate>
	  <guid>/blog/2013/07/28/email-address-validation-in-ios</guid>
	  <description><![CDATA[
	     <p>This post is about <a href="https://github.com/sammyd/GuardPost-ObjectiveC">GuardPost-ObjectiveC</a></p>
<ul>
  <li>an objC wrapper around MailGun’s email validation web service. Checkout the
project on <a href="https://github.com/sammyd/GuardPost-ObjectiveC">GitHub</a> or read on
for more info…</li>
</ul>

<hr />

<p>Email address validation can be really hard work. We’ve all spent many hours
attempting to write a reasonable
<a href="http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address/719543#719543">regular expression</a>
to make sure that our users aren’t mis-typing their email address, but regex
doesn’t catch everything.</p>

<p>MailGun <a href="http://blog.mailgun.com/post/free-email-validation-api-for-web-forms/">recently released</a>
a new API called GuardPost, which is used for validating
email addresses - checking not only the parts of the email address, but also that
the domain exists and has a responsive mail exchanger. It also offers suggestions
for common mis-spellings of email addresses - e.g. <code class="highlighter-rouge">gmial.com</code> will result in a
suggestion of <code class="highlighter-rouge">gmail.com</code>.</p>

<p>This weekend I have built an objC wrapper around the new mailgun GuardPost API,
and I’ll explain how to use it here.</p>

<!-- more -->

<h2 id="guardpost">GuardPost</h2>

<p>GuardPost is part of the web service offered by mailgun, and allows validation
of email addresses. It has a really simple API - details of which can be found
in their <a href="http://documentation.mailgun.com/api-email-validation.html">documentation</a>.
The two methods it offers are as follows:</p>

<ul>
  <li><strong>Validation</strong> This takes a string and attempts to determine whether it is a
valid email address. Not only does it check the construction of the string against
a grammar, but also whether the domain exists and whether it supports a mail
exchanger. Suggestions for common mis-spellings are also offered.</li>
  <li><strong>Parsing</strong> Given a string containing multiple email addresses (comma or
semi-colon delimited) this tool attempts to split them up into valid email addresses
and unparseable string sections.</li>
</ul>

<p>The GuardPost API is free to use, but requires an API key from mailgun. You can
sign up for a free account <a href="https://mailgun.com/">here</a>.</p>

<h2 id="guardpost-objectivec">GuardPost-ObjectiveC</h2>

<h3 id="installation">Installation</h3>

<p>GuardPost-ObjectiveC is a friendly wrapper around the mailgun service - based on
<a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>. It is packaged up
as a CocoaPod so installation is simple:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">platform</span> <span class="ss">:ios</span><span class="p">,</span> <span class="s1">'5.0'</span>

<span class="n">pod</span> <span class="s1">'GuardPost-ObjectiveC'</span><span class="p">,</span> <span class="s1">'~&gt; 0.1.1'</span></code></pre></figure>

<p>And then installation (as with every other CocoaPod) is as simple as:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>pod install</code></pre></figure>

<p>This installs the dependencies as well as GuardPost-ObjectiveC itself.</p>

<h3 id="usage">Usage</h3>

<p>The class which provides the required functionality is <code class="highlighter-rouge">GPGuardPost</code>, and it
is provided by the <code class="highlighter-rouge">GPGuardPost.h</code> header.</p>

<p>Before attempting to verify an email address you need to specify your mailgun
API key. This is the public API key - with a prefix of <code class="highlighter-rouge">pubkey-</code>. To set it use
the <code class="highlighter-rouge">setPublicAPIKey:</code> class method. This only has to be done once per application
so it might make sense to do it in the app delegate:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="cp">#import &lt;GPGuardPost.h&gt;
</span>
<span class="k">@implementation</span> <span class="nc">AppDelegate</span>

<span class="k">-</span> <span class="p">(</span><span class="n">BOOL</span><span class="p">)</span><span class="nf">application</span><span class="p">:(</span><span class="n">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span> <span class="nf">didFinishLaunchingWithOptions</span><span class="p">:(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">launchOptions</span>
<span class="p">{</span>
    <span class="c1">// Register the mailgun API Key
</span>    <span class="p">[</span><span class="n">GPGuardPost</span> <span class="nf">setPublicAPIKey</span><span class="p">:</span><span class="s">@"pubkey-from-mailgun"</span><span class="p">];</span>

    <span class="c1">// Other app launch options here...
</span>
    <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="k">@end</span></code></pre></figure>

<p>Now you’re all set to go.</p>

<h4 id="email-address-validation">Email Address Validation</h4>

<p>To verify an email address use the class method
<code class="highlighter-rouge">+validateAddress:success:failure:</code>. It takes a string for the address, and 2
blocks - one for success, the other for failure.</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="p">[</span><span class="n">GPGuardPost</span> <span class="nf">validateAddress</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">emailField</span><span class="p">.</span><span class="n">text</span>
                     <span class="nf">success</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">BOOL</span> <span class="n">validity</span><span class="p">,</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">suggestion</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">NSLog</span><span class="p">(</span><span class="s">@"API call successful"</span><span class="p">);</span>
                     <span class="p">}</span>
                     <span class="n">failure</span><span class="o">:^</span><span class="p">(</span><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">NSLog</span><span class="p">(</span><span class="s">@"There was an error: %@"</span><span class="p">,</span> <span class="p">[</span><span class="n">error</span> <span class="nf">localizedDescription</span><span class="p">]);</span>
                     <span class="p">}];</span></code></pre></figure>

<p>The success block has 2 arguments:</p>

<ul>
  <li><code class="highlighter-rouge">validity</code> is a BOOL which specifies whether the email address sent is valid</li>
  <li><code class="highlighter-rouge">suggestion</code> is an NSString which has a suggestion for an email address, or is
<code class="highlighter-rouge">nil</code>. Note that valid email addresses can have a non-<code class="highlighter-rouge">nil</code> suggestion, and
similarly invalid addresses don’t necessarily have a suggestion.</li>
</ul>

<p>The error block has an <code class="highlighter-rouge">NSError</code> argument, which will contain details of the
problem - e.g. a <code class="highlighter-rouge">401</code> message in the event of authorization failure.</p>

<h4 id="email-list-parsing">Email List Parsing</h4>

<p>The <code class="highlighter-rouge">+parseListOfAddresses:success:failure</code> method mirrors the API call provided
by mailgun. Provided a string which contains a list of addresses the method again
has <code class="highlighter-rouge">success</code> and <code class="highlighter-rouge">failure</code> callback blocks. The failure block is of the same form
as for email validation.</p>

<p>The success block has 2 <code class="highlighter-rouge">NSArray</code> arguments - the first for a list of parsed email
addresses, and the second for unparseable parts of the list string. Note that
these email addresses have only been parsed for grammar, and additional validation
can then be performed with calls to the <code class="highlighter-rouge">validateAddress</code> method.</p>

<h2 id="example-app">Example App</h2>

<p>Inside the <code class="highlighter-rouge">GuardPost-ObjectiveC</code> repo there is a Samples directory, which contains
an example application. This is a really simple app which verifies an email address
as valid and updates the UI as appropriate.</p>

<p><img src="/images/2013-07-28-email-validator-app.png" alt="Email validator app" />
<img src="/images/2013-07-28-email-validator-app-invalid.png" alt="Invalid email" /></p>

<p>We create the UI in a storyboard and provide the following outlets and methods
in the header file:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@interface</span> <span class="nc">GPViewController</span> <span class="p">:</span> <span class="nc">UIViewController</span> <span class="o">&lt;</span><span class="n">UITextFieldDelegate</span><span class="o">&gt;</span>

<span class="k">@property</span> <span class="p">(</span><span class="n">weak</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">IBOutlet</span> <span class="n">UITextField</span> <span class="o">*</span><span class="n">emailField</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">weak</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">IBOutlet</span> <span class="n">UILabel</span> <span class="o">*</span><span class="n">lblValid</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">weak</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">IBOutlet</span> <span class="n">UILabel</span> <span class="o">*</span><span class="n">lblDidYouMean</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">weak</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">IBOutlet</span> <span class="n">UIButton</span> <span class="o">*</span><span class="n">btnValidate</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">weak</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">IBOutlet</span> <span class="n">UIActivityIndicatorView</span> <span class="o">*</span><span class="n">actIndicator</span><span class="p">;</span>

<span class="k">-</span> <span class="p">(</span><span class="n">IBAction</span><span class="p">)</span><span class="nf">btnValidatePressed</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">sender</span><span class="p">;</span>
<span class="k">@end</span></code></pre></figure>

<p>The implementation which goes alongside this as follows. It’s refreshingly
simple:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="cp">#import "GPViewController.h"
#import &lt;GPGuardPost.h&gt;
</span>
<span class="k">@implementation</span> <span class="nc">ViewController</span>

<span class="k">-</span> <span class="p">(</span><span class="n">IBAction</span><span class="p">)</span><span class="nf">btnValidatePressed</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">sender</span> <span class="p">{</span>
    <span class="c1">// Bin off the keyboard
</span>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">emailField</span> <span class="nf">resignFirstResponder</span><span class="p">];</span>
    <span class="c1">// Start the spinner
</span>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">actIndicator</span> <span class="nf">startAnimating</span><span class="p">];</span>
    
    <span class="c1">// Send the email address off for validation
</span>    <span class="p">[</span><span class="n">GPGuardPost</span> <span class="nf">validateAddress</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">emailField</span><span class="p">.</span><span class="n">text</span> <span class="nf">success</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">BOOL</span> <span class="n">validity</span><span class="p">,</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">suggestion</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Hide the spinner
</span>        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">actIndicator</span> <span class="nf">stopAnimating</span><span class="p">];</span>
        
        <span class="c1">// Update the validity label
</span>        <span class="k">if</span><span class="p">(</span><span class="n">validity</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">self</span><span class="p">.</span><span class="n">lblValid</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">@"VALID"</span><span class="p">;</span>
            <span class="n">self</span><span class="p">.</span><span class="n">lblValid</span><span class="p">.</span><span class="n">textColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="nf">greenColor</span><span class="p">];</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">self</span><span class="p">.</span><span class="n">lblValid</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">@"INVALID"</span><span class="p">;</span>
            <span class="n">self</span><span class="p">.</span><span class="n">lblValid</span><span class="p">.</span><span class="n">textColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="nf">redColor</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">self</span><span class="p">.</span><span class="n">lblValid</span><span class="p">.</span><span class="n">hidden</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
        
        <span class="c1">// And now check for suggestions:
</span>        <span class="k">if</span><span class="p">(</span><span class="n">suggestion</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">self</span><span class="p">.</span><span class="n">lblDidYouMean</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nf">stringWithFormat</span><span class="p">:</span><span class="s">@"Did you mean %@?"</span><span class="p">,</span> <span class="n">suggestion</span><span class="p">];</span>
            <span class="n">self</span><span class="p">.</span><span class="n">lblDidYouMean</span><span class="p">.</span><span class="n">hidden</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="n">failure</span><span class="o">:^</span><span class="p">(</span><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Hide the spinner
</span>        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">actIndicator</span> <span class="nf">stopAnimating</span><span class="p">];</span>
        <span class="n">self</span><span class="p">.</span><span class="n">lblValid</span><span class="p">.</span><span class="n">textColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="nf">orangeColor</span><span class="p">];</span>
        <span class="n">self</span><span class="p">.</span><span class="n">lblValid</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">@"Error"</span><span class="p">;</span>
        <span class="n">self</span><span class="p">.</span><span class="n">lblValid</span><span class="p">.</span><span class="n">hidden</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
        <span class="n">self</span><span class="p">.</span><span class="n">lblDidYouMean</span><span class="p">.</span><span class="n">hidden</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@"There was an error: %@"</span><span class="p">,</span> <span class="p">[</span><span class="n">error</span> <span class="nf">localizedDescription</span><span class="p">]);</span>
    <span class="p">}];</span>
<span class="p">}</span>
<span class="k">@end</span></code></pre></figure>

<p>You can see the <code class="highlighter-rouge">success</code> and <code class="highlighter-rouge">failure</code> blocks clearly. The majority of this code
is getting the right UI elements to appear at the right time with the correct
content. The call to validate the email address is really simple.</p>

<p>To improve the usability we implement the following <code class="highlighter-rouge">UITextFieldDelegate</code> method
which will empty the textfield when the keyboard shows, and also hide any previous
result displays:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="cp">#pragma mark - UITextFieldDelegate methods
</span><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">textFieldDidBeginEditing</span><span class="p">:(</span><span class="n">UITextField</span> <span class="o">*</span><span class="p">)</span><span class="nv">textField</span>
<span class="p">{</span>
    <span class="c1">// Empty the text field
</span>    <span class="n">self</span><span class="p">.</span><span class="n">emailField</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="c1">// Hide the result fields
</span>    <span class="n">self</span><span class="p">.</span><span class="n">lblValid</span><span class="p">.</span><span class="n">hidden</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
    <span class="n">self</span><span class="p">.</span><span class="n">lblDidYouMean</span><span class="p">.</span><span class="n">hidden</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<h2 id="conclusion">Conclusion</h2>

<p>Hopefully you might find this useful. I think it’s a great service from mailgun - 
validating email addresses is often a fiddly job, and now it’s a lot simpler.</p>

<p>If you have any suggestions/improvements then send a pull request or raise an
issue on the <a href="https://github.com/sammyd/GuardPost-ObjectiveC">GitHub</a> repo.</p>

<p>If you’ve enjoyed this post then you should follow me on twitter 
<a href="https://twitter.com/iwantmyrealname">@iwantmyrealname</a> or adn 
<a href="https://app.net/samd">@samd</a>.</p>

<p>sam</p>

	  ]]></description>
	</item>

	<item>
	  <title>Radar: UITableView cell index inconsistent state after editing</title>
	  <link>/blog/2013/05/09/radar-uitableview-cell-index-inconsistent-state-after-editing</link>
	  <author>Sam Davies</author>
	  <pubDate>2013-05-09T08:59:00+00:00</pubDate>
	  <guid>/blog/2013/05/09/radar-uitableview-cell-index-inconsistent-state-after-editing</guid>
	  <description><![CDATA[
	     <p>When working on <code class="highlighter-rouge">UITableView</code> I came across a bug in iOS, and have just got around
to filing my first ever apple bug report. Under certain conditions it’s possible
to get the index paths of cells in the table to become inconsistent with the content.</p>

<p>Filed as rdar://13846681 and on <a href="http://openradar.appspot.com/13846681">OpenRadar</a>.</p>

<h3 id="summary">Summary</h3>

<p>It’s possible to get a <code class="highlighter-rouge">UITableView</code> with differing cell heights into a state
where the cell index paths are inconsistent with the datasource.</p>

<!-- more -->

<h3 id="steps-to-reproduce">Steps to Reproduce</h3>

<ol>
  <li>Create a <code class="highlighter-rouge">UITableView</code> in which the topmost cell is over twice the height of
the one immediately below it.</li>
  <li>Enable editing (specifically we want row reordering).</li>
  <li>Enter edit mode and scroll the table down so that you can only just see the
reordering grabber on the top cell.</li>
  <li>Tap the grabber. This will switch cells 0 and 1 (due to the height difference).</li>
</ol>

<p>The problem occurs only when the row switch causes a row to disappear off screen
(hence why we need the top row to be over double the height of the one below it).</p>

<h3 id="expected-results">Expected Results</h3>

<p>The <code class="highlighter-rouge">tableView:moveRowAtIndexPath:toIndexPath:</code> datasource method should be called
with the correct index paths, and the index paths of the cells in the table should
be updated appropriately.</p>

<h3 id="actual-results">Actual Results</h3>

<p>The datasource method is called correctly, but the cells in the table are left with
inconsistent index paths.</p>

<h3 id="regression">Regression</h3>

<p>Tested in iOS 4, 5 &amp; 6 with the same results.</p>

<h3 id="notes">Notes</h3>

<p>I have attached a sample project which demonstrates this. To see the effects:</p>

<ol>
  <li>Open the project</li>
  <li>Click the edit button</li>
  <li>Scroll the table down so that the grabber icon is only just visible for the
top cell (cell 0).</li>
  <li>Single tap the reordering grabber.</li>
</ol>

<p>The table now has an inconsistent index path state. The log status button shows
the index path (row) for each of the cells currently visible table, and the
corresponding index of the content of that cell in the backing array. These should
always match. Pressing it after the above actions will reveal that this isn’t the
case, and if you scroll back to the top of the table and log the status again
you’ll see that some of the cell content is repeated. Further scrolling of the
table will cause blank rows to appear etc.</p>

<h2 id="sample-project">Sample project</h2>

<p>The sample project which I uploaded is available on GitHub at
<a href="https://github.com/sammyd/UITableView-RadarSample">github.com/sammyd/UITableView-RadarSample</a>.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Building a range selector with ShinobiCharts: Part IV - Adding a value-tracking annotation</title>
	  <link>/blog/2013/03/10/building-a-range-selector-with-shinobi-charts-part-iv-adding-a-value-tracking-annotation</link>
	  <author>Sam Davies</author>
	  <pubDate>2013-03-10T21:33:00+00:00</pubDate>
	  <guid>/blog/2013/03/10/building-a-range-selector-with-shinobi-charts-part-iv-adding-a-value-tracking-annotation</guid>
	  <description><![CDATA[
	     <blockquote>
  <p>This tutorial is also available on the <a href="http://www.shinobicontrols.com/blog/posts/2013/05/building-a-range-selector-with-shinobicharts-part-iv">ShinobiControls</a>
blog. You’ll find better support and assistance on this site as part of
<a href="http://www.shinobicontrols.com/shinobideveloper">ShinobiDeveloper</a></p>
</blockquote>

<p>Welcome to the fourth (and probably final) post in my series about building
a range selector using ShinobiCharts for iOS. If you haven’t already read the
previous parts then it might be worth a look to describe how we got to where we
are now
(<a href="/blog/2013/01/11/building-a-range-selector-with-shinobi-charts-part-i-linking-2-charts">part I</a>,
<a href="/blog/2013/01/15/building-a-range-selector-with-shinobi-charts-part-ii-creating-custom-handle-annotations">part II</a>,
<a href="/blog/2013/01/19/building-a-range-selector-with-shinobi-charts-part-iii-adding-momentum">part III</a>).</p>

<p>In this post we’re going to look at a couple of things:</p>

<ol>
  <li>When we first start the app the range selector should be showing a default
range. At the moment it shows the entire range as being selected, but this isn’t
ideal. We’ll look at how to specify an initial range.</li>
  <li>We’re going to add a value annotation, which displays the value of the right-most
datapoint visible on the chart. This will take the form of a horizontal line
across the chart with a text label at the right hand side:
<img src="/images/2013-03-10-value-annotation.png" alt="Value Annotation" /></li>
</ol>

<p>This part of the tutorial describes the more recent commits in the GitHub
repository available at
<a href="https://github.com/sammyd/Shinobi-RangeSelector">github.com/sammyd/Shinobi-RangeSelector</a>.
You can check out the code there as a fully-working demo app, or just follow along
with the code we develop in tutorial.</p>

<!-- more -->

<h2 id="initial-range-selection">Initial Range Selection</h2>

<p>When we first start the app, the visible range on the chart is by default the
entire data range, and consequently it’s not obvious that there even is a range
selector. We’re going to add a simple call on to the end of the range selector’s
constructor to a new method:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="nf">initWithFrame</span><span class="p">:(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">frame</span>
         <span class="nf">datasource</span><span class="p">:(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">SChartDatasource</span><span class="p">,</span> <span class="n">SChartDatasourceLookup</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">datasource</span> 
    <span class="nf">splitProportion</span><span class="p">:(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">proportion</span>
<span class="p">{</span>
    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nf">initWithFrame</span><span class="p">:</span><span class="n">frame</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="c1">// And now prepare the default range
</span>        <span class="p">[</span><span class="n">self</span> <span class="nf">configureTheDefaultRange</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>This method is going to set the initial range displayed by the range selector.
Since we don’t really know anything about the data, we’ve arbitrarily chosen to
display the 4th 20% of the timeline. You can see how to adapt this method to
a different range, possibly even provided in the constructor of the range selector.</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">configureTheDefaultRange</span>
<span class="p">{</span>
    <span class="n">NSInteger</span> <span class="n">numberPoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">chartDatasource</span> <span class="nf">sChart</span><span class="p">:</span><span class="n">mainChart</span> <span class="nf">numberOfDataPointsForSeriesAtIndex</span><span class="p">:</span><span class="mi">0</span><span class="p">];</span>
    <span class="c1">// Let's make the default range the 4th 20% of data points
</span>    <span class="c1">// NB: we're assuming here that the datapoints are in ascending order of x. This isn't
</span>    <span class="c1">//  always true, but it is for our data set, so we'll live with it.
</span>    <span class="n">NSInteger</span> <span class="n">startIndex</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">numberPoints</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">6</span><span class="p">);</span>
    <span class="n">NSInteger</span> <span class="n">endIndex</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">numberPoints</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">8</span><span class="p">);</span>
    
    <span class="c1">// Find the correct points
</span>    <span class="n">SChartDataPoint</span> <span class="o">*</span><span class="n">startPoint</span> <span class="o">=</span> <span class="p">[</span><span class="n">chartDatasource</span> <span class="nf">sChart</span><span class="p">:</span><span class="n">mainChart</span>
                                         <span class="nf">dataPointAtIndex</span><span class="p">:</span><span class="n">startIndex</span>
                                         <span class="n">forSeriesAtIndex</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">SChartDataPoint</span> <span class="o">*</span><span class="n">endPoint</span> <span class="o">=</span> <span class="p">[</span><span class="n">chartDatasource</span> <span class="nf">sChart</span><span class="p">:</span><span class="n">mainChart</span>
                                       <span class="nf">dataPointAtIndex</span><span class="p">:</span><span class="n">endIndex</span>
                                       <span class="n">forSeriesAtIndex</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
    
    <span class="c1">// Need to convert the datapoints to their internal representation - i.e. time interval floats
</span>    <span class="n">NSTimeInterval</span> <span class="n">startTS</span> <span class="o">=</span> <span class="p">[((</span><span class="n">NSDate</span> <span class="o">*</span><span class="p">)</span><span class="n">startPoint</span><span class="p">.</span><span class="n">xValue</span><span class="p">)</span> <span class="nf">timeIntervalSince1970</span><span class="p">];</span>
    <span class="n">NSTimeInterval</span> <span class="n">endTS</span> <span class="o">=</span> <span class="p">[((</span><span class="n">NSDate</span> <span class="o">*</span><span class="p">)</span><span class="n">endPoint</span><span class="p">.</span><span class="n">xValue</span><span class="p">)</span> <span class="nf">timeIntervalSince1970</span><span class="p">];</span>
    
    <span class="n">SChartRange</span> <span class="o">*</span><span class="n">defaultRange</span> <span class="o">=</span> <span class="p">[[</span><span class="n">SChartRange</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithMinimum</span><span class="p">:</span><span class="err">@</span><span class="p">(</span><span class="n">startTS</span><span class="p">)</span> <span class="nf">andMaximum</span><span class="p">:</span><span class="err">@</span><span class="p">(</span><span class="n">endTS</span><span class="p">)];</span>
    
    <span class="c1">// And now set the default range to this range
</span>    <span class="p">[</span><span class="n">mainChart</span><span class="p">.</span><span class="n">xAxis</span> <span class="nf">setDefaultRange</span><span class="p">:</span><span class="n">defaultRange</span><span class="p">];</span>
    <span class="p">[</span><span class="n">mainChart</span><span class="p">.</span><span class="n">xAxis</span> <span class="nf">resetZoomLevel</span><span class="p">];</span>
    
    <span class="c1">// And update the annotation appropriately
</span>    <span class="p">[</span><span class="n">rangeAnnotationManager</span> <span class="nf">moveRangeSelectorToRange</span><span class="p">:</span><span class="n">defaultRange</span><span class="p">];</span>
<span class="p">}</span></code></pre></figure>

<p>This method performs the following:</p>
<ol>
  <li>We find the start and end datapoints for our range.</li>
  <li>Create the <code class="highlighter-rouge">SChartRange</code> we wish to show. We could use <code class="highlighter-rouge">NSDate</code>s here, but
since when we ask the axis for the range later on we get <code class="highlighter-rouge">NSNumbers</code> back, we
choose to stick to the same convention.</li>
  <li>We set the xAxis range from our constructed range</li>
  <li>Update the range annotation with our constructed range.</li>
</ol>

<p>This is all fairly simple. The only point worth making is that we use a different
<code class="highlighter-rouge">SChartDatasource</code> method to retrieve individual data points than we used before.
There are 2 different ways that a <code class="highlighter-rouge">SChartDatasource</code> can provide the data points
to a chart - either an <code class="highlighter-rouge">NSArray</code> of all the data points at once, or individually.
We have previously only implemented the array method, but here we use the single
datapoint as well. It’s simple to update the <code class="highlighter-rouge">ChartDatasource</code> to implement this
additional method:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">SChartData</span><span class="o">&gt;</span><span class="p">)</span><span class="nf">sChart</span><span class="p">:(</span><span class="n">ShinobiChart</span> <span class="o">*</span><span class="p">)</span><span class="nv">chart</span>
        <span class="nf">dataPointAtIndex</span><span class="p">:(</span><span class="kt">int</span><span class="p">)</span><span class="nv">dataIndex</span>
        <span class="nf">forSeriesAtIndex</span><span class="p">:(</span><span class="kt">int</span><span class="p">)</span><span class="nv">seriesIndex</span>
<span class="p">{</span>
    <span class="c1">// Find the underlying temperature data point
</span>    <span class="n">TemperatureDataPoint</span> <span class="o">*</span><span class="n">tdp</span> <span class="o">=</span> <span class="n">temperatureData</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="nf">dataIndex</span><span class="p">];</span>
    <span class="c1">// Turn this into a chart data point
</span>    <span class="n">SChartDataPoint</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="n">SChartDataPoint</span> <span class="nf">new</span><span class="p">];</span>
    <span class="n">dp</span><span class="p">.</span><span class="n">xValue</span> <span class="o">=</span> <span class="n">tdp</span><span class="p">.</span><span class="n">timestamp</span><span class="p">;</span>
    <span class="n">dp</span><span class="p">.</span><span class="n">yValue</span> <span class="o">=</span> <span class="n">tdp</span><span class="p">.</span><span class="n">temperature</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">dp</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>We find the relevant <code class="highlighter-rouge">TemperatureDataPoint</code> in our underlying data array, and then
construct an appropriate <code class="highlighter-rouge">SChartDatapoint</code> from it.</p>

<h3 id="wheres-the-shading-gone">Where’s the shading gone?</h3>

<p><img src="/images/2013-03-10-range-selector-without-shading.png" alt="Without Shading" /></p>

<p>There is one more slight niggle with this implementation - the initial rendering
of the range selector doesn’t properly render the shaded regions. This is because
they use the x-axis limits to work out their endpoints. Unfortunately, the axis
range hasn’t been calculated at the point where we call <code class="highlighter-rouge">moveRangeSelectorToRange:</code> in
<code class="highlighter-rouge">configureTheDefaultRange</code>.</p>

<p>To get around this limitation, we’re going to add another method to the API of
the range selector, and set the initial limits ourselves:</p>

<figure class="highlight"><pre><code class="language-shinobirangeannotationmanager.h" data-lang="shinobirangeannotationmanager.h">...
- (void)setInitialMin:(id)min andMax:(id)max;
...</code></pre></figure>

<p>which has the following simple implementation:</p>

<figure class="highlight"><pre><code class="language-shinobirangeannotationmanager.m" data-lang="shinobirangeannotationmanager.m">- (void)setInitialMin:(id)min andMax:(id)max
{
    leftShading.xValue = min;
    rightShading.xValueMax = max;
}</code></pre></figure>

<p>Now, at the end of the <code class="highlighter-rouge">configureTheDefaultRange</code> method, we determine what the
axis limits will be (using the datasource, and once again assuming that the
datapoints will be increasing in timestamp), and set the initial range of the
range annotation:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">configureTheDefaultRange</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">// We also want to set the min/max since it's not available from the axis yet
</span>    <span class="n">SChartDataPoint</span> <span class="o">*</span><span class="n">minDP</span> <span class="o">=</span> <span class="p">[</span><span class="n">chartDatasource</span> <span class="nf">sChart</span><span class="p">:</span><span class="n">mainChart</span>
                                    <span class="nf">dataPointAtIndex</span><span class="p">:</span><span class="mi">0</span>
                                    <span class="n">forSeriesAtIndex</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">SChartDataPoint</span> <span class="o">*</span><span class="n">maxDP</span> <span class="o">=</span> <span class="p">[</span><span class="n">chartDatasource</span> <span class="nf">sChart</span><span class="p">:</span><span class="n">mainChart</span>
                                    <span class="nf">dataPointAtIndex</span><span class="p">:(</span><span class="n">numberPoints</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                                    <span class="n">forSeriesAtIndex</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">[</span><span class="n">rangeAnnotationManager</span> <span class="nf">setInitialMin</span><span class="p">:</span><span class="n">minDP</span><span class="p">.</span><span class="n">xValue</span> <span class="nf">andMax</span><span class="p">:</span><span class="n">maxDP</span><span class="p">.</span><span class="n">xValue</span><span class="p">];</span>
<span class="p">}</span></code></pre></figure>

<p>And there - we’re done. The range selector now has a nice initial range, and it
renders perfectly from the instant the chart appears.</p>

<h2 id="value-annotation">Value Annotation</h2>

<p>The value annotation we want to add is comprised of 2 separate parts – a horizontal
line and a text annotation which is anchored to the line:</p>

<p><img src="/images/2013-03-10-value-annotation.png" alt="Value Annotation" /></p>

<p>As the user interacts with the chart (either through the range annotation, or
the chart itself) the position of the value annotation tracks the y-Value of the
rightmost datapoint displayed on the chart. The value displayed in the text
annotation will also update to show the same y-Value.</p>

<h3 id="annotation-manager">Annotation Manager</h3>

<p>In the same way that we created a class to manage the range annotation, we’ll
create a <code class="highlighter-rouge">ShinobiValueAnnotationManager</code> class:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@interface</span> <span class="nc">ShinobiValueAnnotationManager</span> <span class="p">:</span> <span class="nc">NSObject</span>

<span class="k">-</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="nf">initWithChart</span><span class="p">:(</span><span class="n">ShinobiChart</span> <span class="o">*</span><span class="p">)</span><span class="nv">chart</span>
         <span class="nf">datasource</span><span class="p">:(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">SChartDatasourceLookup</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">datasource</span>
        <span class="nf">seriesIndex</span><span class="p">:(</span><span class="n">NSInteger</span><span class="p">)</span><span class="nv">seriesIndex</span><span class="p">;</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">updateValueAnnotationForXAxisRange</span><span class="p">:(</span><span class="n">SChartRange</span> <span class="o">*</span><span class="p">)</span><span class="nv">range</span><span class="p">;</span>

<span class="k">@end</span></code></pre></figure>

<p>There are just 2 methods on the API of this manager class - the first one a
constructor, and the second the method which will update the value annotation
as the chart pans and zooms. Two of the variables provided to the constructor
are self explanatory, but the datasource is an object which conforms to an as-yet
undefined protocol. We’ll come back to explaining this later, once we’ve finished
discovered why it is necessary.</p>

<p>In the implementation file for this class we define some ivars and the constructor
as follows:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@interface</span> <span class="nc">ShinobiValueAnnotationManager</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">ShinobiChart</span> <span class="o">*</span><span class="n">chart</span><span class="p">;</span>
    <span class="n">id</span><span class="o">&lt;</span><span class="n">SChartDatasourceLookup</span><span class="o">&gt;</span> <span class="n">datasource</span><span class="p">;</span>
    <span class="n">NSInteger</span> <span class="n">seriesIndex</span><span class="p">;</span>
    <span class="n">SChartAnnotation</span> <span class="o">*</span><span class="n">lineAnnotation</span><span class="p">;</span>
    <span class="n">SChartAnnotation</span> <span class="o">*</span><span class="n">textAnnotation</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">ShinobiValueAnnotationManager</span>
<span class="k">-</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">init</span>
<span class="p">{</span>
    <span class="n">NSException</span> <span class="o">*</span><span class="n">exception</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSException</span> <span class="nf">exceptionWithName</span><span class="p">:</span><span class="n">NSInvalidArgumentException</span>
                                                     <span class="nf">reason</span><span class="p">:</span><span class="s">@"Please use initWithChart:seriesIndex:"</span>
                                                   <span class="n">userInfo</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
    <span class="k">@throw</span> <span class="n">exception</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">initWithChart</span><span class="o">:</span><span class="p">(</span><span class="n">ShinobiChart</span> <span class="o">*</span><span class="p">)</span><span class="n">_chart</span>
         <span class="n">datasource</span><span class="o">:</span><span class="p">(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">SChartDatasourceLookup</span><span class="o">&gt;</span><span class="p">)</span><span class="n">_datasource</span>
        <span class="n">seriesIndex</span><span class="o">:</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">)</span><span class="n">_seriesIndex</span>
<span class="p">{</span>
    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nf">init</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">chart</span> <span class="o">=</span> <span class="n">_chart</span><span class="p">;</span>
        <span class="n">seriesIndex</span> <span class="o">=</span> <span class="n">_seriesIndex</span><span class="p">;</span>
        <span class="n">datasource</span> <span class="o">=</span> <span class="n">_datasource</span><span class="p">;</span>
        <span class="p">[</span><span class="n">self</span> <span class="nf">createLine</span><span class="p">];</span>
        <span class="p">[</span><span class="n">self</span> <span class="nf">createText</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@end</span></code></pre></figure>

<p>We have ivars for the 2 separate annotations which make up the value annotation
(the text component and the line component), along with 3 ivars for the variables
we provide in the constructor. The constructor saves these off, and then calls
some utility methods which will create the annotations. Note that we have also
overridden the default constructor to throw and exception, since we require the
usage of our own constructor.</p>

<p>To create the individual annotations we use the utility methods <code class="highlighter-rouge">createLine</code> and
<code class="highlighter-rouge">createText</code>.</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@implementation</span> <span class="nc">ShinobiValueAnnotationManger</span>
<span class="p">...</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">createLine</span>
<span class="p">{</span>
    <span class="c1">// Really simple line
</span>    <span class="n">lineAnnotation</span> <span class="o">=</span> <span class="p">[</span><span class="n">SChartAnnotation</span> <span class="nf">horizontalLineAtPosition</span><span class="p">:</span><span class="nb">nil</span>
                                                      <span class="nf">withXAxis</span><span class="p">:</span><span class="n">chart</span><span class="p">.</span><span class="n">xAxis</span>
                                                       <span class="n">andYAxis</span><span class="o">:</span><span class="n">chart</span><span class="p">.</span><span class="n">yAxis</span>
                                                      <span class="n">withWidth</span><span class="o">:</span><span class="mi">1</span><span class="p">.</span><span class="n">f</span>
                                                      <span class="n">withColor</span><span class="o">:</span><span class="p">[</span><span class="n">UIColor</span> <span class="nf">blackColor</span><span class="p">]];</span>
    <span class="p">[</span><span class="n">chart</span> <span class="nf">addAnnotation</span><span class="p">:</span><span class="n">lineAnnotation</span><span class="p">];</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">createText</span>
<span class="p">{</span>
    <span class="c1">// Create the font
</span>    <span class="n">UIFont</span> <span class="o">*</span><span class="n">labelFont</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIFont</span> <span class="nf">fontWithName</span><span class="p">:</span><span class="s">@"Nunito-Bold"</span> <span class="nf">size</span><span class="p">:</span><span class="mi">18</span><span class="p">.</span><span class="n">f</span><span class="p">];</span>
    <span class="k">if</span><span class="p">(</span><span class="n">labelFont</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">labelFont</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIFont</span> <span class="nf">systemFontOfSize</span><span class="p">:</span><span class="mi">18</span><span class="p">.</span><span class="n">f</span><span class="p">];</span>
    <span class="p">}</span>
    
    <span class="c1">// Create our text annotation subclass. We set the text to be the widest of our possible values
</span>    <span class="c1">//  since we only size the annotation at construction time.
</span>    <span class="n">textAnnotation</span> <span class="o">=</span> <span class="p">[[</span><span class="n">ShinobiAnchoredTextAnnotation</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithText</span><span class="p">:</span><span class="s">@"MM.MM"</span>
                                                                 <span class="nf">andFont</span><span class="p">:</span><span class="n">labelFont</span>
                                                               <span class="n">withXAxis</span><span class="o">:</span><span class="n">chart</span><span class="p">.</span><span class="n">xAxis</span>
                                                                <span class="n">andYAxis</span><span class="o">:</span><span class="n">chart</span><span class="p">.</span><span class="n">yAxis</span>
                                                             <span class="n">atXPosition</span><span class="o">:</span><span class="nb">nil</span>
                                                            <span class="n">andYPosition</span><span class="o">:</span><span class="nb">nil</span>
                                                           <span class="n">withTextColor</span><span class="o">:</span><span class="p">[</span><span class="n">UIColor</span> <span class="nf">whiteColor</span><span class="p">]</span>
                                                     <span class="n">withBackgroundColor</span><span class="o">:</span><span class="p">[</span><span class="n">UIColor</span> <span class="nf">blackColor</span><span class="p">]];</span>
    <span class="p">[</span><span class="n">chart</span> <span class="nf">addAnnotation</span><span class="p">:</span><span class="n">textAnnotation</span><span class="p">];</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="k">@end</span></code></pre></figure>

<p>The <code class="highlighter-rouge">createLine</code> method is self-explanatory. We simply use the appropriate
factory method provided by the <code class="highlighter-rouge">SChartAnnotation</code> class, setting the appropriate
values, and then add the annotation to the chart. We don’t worry about the initial
position, since this will be set as the chart updates its position.</p>

<p>The <code class="highlighter-rouge">createText</code> method is a little more complicated - we don’t use an existing
factory method, but instead we have created our own <code class="highlighter-rouge">SChartAnnotation</code> subclass.
You might be surprised by this, since there is a factory method on <code class="highlighter-rouge">SChartAnnotation</code>
which can create a text annotation
(<code class="highlighter-rouge">+ annotationWithText:andFont:withXAxis:andYAxis:atXPosition:
andYPosition:withTextColor:withBackgroundColor:</code>), however there is a reason behind this.
The factory method creates an annotation
which is anchored with the centre-point at the x/y coordinates provided, however
we need to be able to position the bottom right corner of the annotation at the
coordinates we provide, since we are placing it on the right hand edge of the chart.</p>

<h3 id="custom-text-annotation">Custom Text Annotation</h3>

<p>The <code class="highlighter-rouge">ShinobiAnchoredTextAnnotation</code> class is a pretty simple subclass of
<code class="highlighter-rouge">SChartAnnotation</code>:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@interface</span> <span class="nc">ShinobiAnchoredTextAnnotation</span> <span class="p">:</span> <span class="nc">SChartAnnotation</span>

 <span class="k">-</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="nf">initWithText</span><span class="p">:(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">text</span>
            <span class="nf">andFont</span><span class="p">:(</span><span class="n">UIFont</span><span class="o">*</span><span class="p">)</span><span class="nv">font</span>
          <span class="nf">withXAxis</span><span class="p">:(</span><span class="n">SChartAxis</span><span class="o">*</span><span class="p">)</span><span class="nv">xAxis</span>
           <span class="nf">andYAxis</span><span class="p">:(</span><span class="n">SChartAxis</span><span class="o">*</span><span class="p">)</span><span class="nv">yAxis</span>
        <span class="nf">atXPosition</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">xPosition</span>
       <span class="nf">andYPosition</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">yPosition</span>
      <span class="nf">withTextColor</span><span class="p">:(</span><span class="n">UIColor</span><span class="o">*</span><span class="p">)</span><span class="nv">textColor</span>
<span class="nf">withBackgroundColor</span><span class="p">:(</span><span class="n">UIColor</span><span class="o">*</span><span class="p">)</span><span class="nv">bgColor</span><span class="p">;</span>

<span class="k">@end</span></code></pre></figure>

<p>The only API method is a constructor which mirrors exactly the aforementioned
factory method for creating a text annotation.</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@implementation</span> <span class="nc">ShinobiAnchoredTextAnnotation</span>

<span class="k">-</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="nf">initWithText</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">text</span> <span class="nf">andFont</span><span class="p">:(</span><span class="n">UIFont</span> <span class="o">*</span><span class="p">)</span><span class="nv">font</span> <span class="nf">withXAxis</span><span class="p">:(</span><span class="n">SChartAxis</span> <span class="o">*</span><span class="p">)</span><span class="nv">xAxis</span>
          <span class="nf">andYAxis</span><span class="p">:(</span><span class="n">SChartAxis</span> <span class="o">*</span><span class="p">)</span><span class="nv">yAxis</span> <span class="nf">atXPosition</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">xPosition</span> <span class="nf">andYPosition</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">yPosition</span>
     <span class="nf">withTextColor</span><span class="p">:(</span><span class="n">UIColor</span> <span class="o">*</span><span class="p">)</span><span class="nv">textColor</span> <span class="nf">withBackgroundColor</span><span class="p">:(</span><span class="n">UIColor</span> <span class="o">*</span><span class="p">)</span><span class="nv">bgColor</span>
<span class="p">{</span>
    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nf">init</span><span class="p">];</span>
    <span class="k">if</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Set all the required properties
</span>        <span class="n">self</span><span class="p">.</span><span class="n">xAxis</span> <span class="o">=</span> <span class="n">xAxis</span><span class="p">;</span>
        <span class="n">self</span><span class="p">.</span><span class="n">yAxis</span> <span class="o">=</span> <span class="n">yAxis</span><span class="p">;</span>
        <span class="n">self</span><span class="p">.</span><span class="n">xValue</span> <span class="o">=</span> <span class="n">xPosition</span><span class="p">;</span>
        <span class="n">self</span><span class="p">.</span><span class="n">yValue</span> <span class="o">=</span> <span class="n">yPosition</span><span class="p">;</span>
        <span class="n">self</span><span class="p">.</span><span class="n">label</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UILabel</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithFrame</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">];</span>
        <span class="n">self</span><span class="p">.</span><span class="n">label</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="n">bgColor</span><span class="p">;</span>
        <span class="n">self</span><span class="p">.</span><span class="n">label</span><span class="p">.</span><span class="n">font</span> <span class="o">=</span> <span class="n">font</span><span class="p">;</span>
        <span class="n">self</span><span class="p">.</span><span class="n">label</span><span class="p">.</span><span class="n">textColor</span> <span class="o">=</span> <span class="n">textColor</span><span class="p">;</span>
        <span class="n">self</span><span class="p">.</span><span class="n">label</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span><span class="p">;</span>
        <span class="n">self</span><span class="p">.</span><span class="n">label</span><span class="p">.</span><span class="n">textAlignment</span> <span class="o">=</span> <span class="n">NSTextAlignmentCenter</span><span class="p">;</span>
        <span class="c1">// Now we can resize the label and ourself to fit the text provided
</span>        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">label</span> <span class="nf">sizeToFit</span><span class="p">];</span>
        <span class="p">[</span><span class="n">self</span> <span class="nf">addSubview</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">label</span><span class="p">];</span>
        <span class="p">[</span><span class="n">self</span> <span class="nf">sizeToFit</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">updateViewWithCanvas</span><span class="p">:(</span><span class="n">SChartCanvas</span> <span class="o">*</span><span class="p">)</span><span class="nv">canvas</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">super</span> <span class="nf">updateViewWithCanvas</span><span class="p">:</span><span class="n">canvas</span><span class="p">];</span>
    <span class="c1">// Let's move us so we are anchored in the bottom right hand corner
</span>    <span class="n">self</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                              <span class="n">self</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">@end</span></code></pre></figure>

<p>The constructor sets up all the appropriate properties on the underlying
<code class="highlighter-rouge">SChartAnnotation</code>, including creating a label. We also resize the label to fit
the initial supplied text, and the annotation itself to fit the label at this point.
This means that when we construct one of these annotations we need to provide some
text which will be used to create the annotation of an appropriate size. There
are alternative ways of sizing the annotation, but in this instance, we are able
to provide some text to size the annotation to at construction time.</p>

<p>The <code class="highlighter-rouge">updateViewWithCanvas:</code> method is a method on the superclass which we can
override to provide positioning fixes (see the API docs). In our overridden method
we simply shift the annotation up and left, with the resultant effect being
that the annotation is then anchored at the bottom right, rather than the centre.</p>

<h3 id="updating-the-value-annotation">Updating the Value Annotation</h3>

<p>Although we have now fully described the constructor for the value annotation manager
there is one more method on the API which we haven’t discussed: <code class="highlighter-rouge">updateValueAnnotationForXAxisRange:</code>
This method is called with the updated x-axis range when the range changes - we’ll
look at where this occurs once we’ve defined the method’s implementation:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">updateValueAnnotationForXAxisRange</span><span class="p">:(</span><span class="n">SChartRange</span> <span class="o">*</span><span class="p">)</span><span class="nv">range</span>
<span class="p">{</span>
    <span class="c1">// The x-value at the end of the current chart range
</span>    <span class="n">id</span> <span class="n">newXValue</span> <span class="o">=</span> <span class="n">range</span><span class="p">.</span><span class="n">maximum</span><span class="p">;</span>

    <span class="c1">// Need to find the y-value at this point
</span>    <span class="n">id</span> <span class="n">lastVisibleDPValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">datasource</span> <span class="nf">estimateYValueForXValue</span><span class="p">:</span><span class="n">newXValue</span>
                                               <span class="nf">forSeriesAtIndex</span><span class="p">:</span><span class="n">seriesIndex</span><span class="p">];</span>
    
    <span class="c1">// Update the annotations yValue and redraw the chart
</span>    <span class="n">lineAnnotation</span><span class="p">.</span><span class="n">yValue</span> <span class="o">=</span> <span class="n">lastVisibleDPValue</span><span class="p">;</span>
    <span class="n">textAnnotation</span><span class="p">.</span><span class="n">yValue</span> <span class="o">=</span> <span class="n">lastVisibleDPValue</span><span class="p">;</span>
    <span class="n">textAnnotation</span><span class="p">.</span><span class="n">xValue</span> <span class="o">=</span> <span class="n">newXValue</span><span class="p">;</span>
    <span class="n">textAnnotation</span><span class="p">.</span><span class="n">label</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nf">stringWithFormat</span><span class="p">:</span><span class="s">@"%0.2f"</span><span class="p">,</span>
                                          <span class="p">[</span><span class="n">lastVisibleDPValue</span> <span class="nf">doubleValue</span><span class="p">]];</span>
    
    <span class="p">[</span><span class="n">chart</span> <span class="nf">redrawChart</span><span class="p">];</span>
<span class="p">}</span></code></pre></figure>

<p>Most of this method is self explanatory - we start by defining what the xValue
is on the right hand side of the chart, find the yValye associated with it and
then update the annotation positions and content - in much the same way as we did
for the range annotation. There is one line in this method which requires more
explanation - that is the <code class="highlighter-rouge">estimateYValueForXValue:</code> message passed to the
<code class="highlighter-rouge">datasource</code> object. When describing the constructor of this manager class, we
glossed over the <code class="highlighter-rouge">id&lt;SChartDatasourceLookup&gt;</code> object we provided. We have
defined a new protocol:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@protocol</span> <span class="nc">SChartDatasourceLookup</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span>

<span class="err">@required</span>
<span class="o">-</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">estimateYValueForXValue</span><span class="o">:</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">xValue</span> <span class="n">forSeriesAtIndex</span><span class="o">:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="n">idx</span><span class="p">;</span>

<span class="k">@end</span></code></pre></figure>

<p>This protocol defines a method which will return a Y value estimate for a given
X value. It isn’t a simple lookup because the x-values we will be sending it
won’t necessarily have datapoints associated with them in the datasource.</p>

<h3 id="implementing-schartdatasourcelookup">Implementing SChartDatasourceLookup</h3>

<p>We need to implement this new protocol on our current chart datasource object
to enable it to be used in the value annotation. Firstly we specify that
<code class="highlighter-rouge">ChartDatasource</code> adopts the <code class="highlighter-rouge">SChartDatasourceLookup</code> protocol:</p>

<figure class="highlight"><pre><code class="language-chartdatasource.h" data-lang="chartdatasource.h">@interface ChartDatasource : NSObject &lt;SChartDatasource, SChartDatasourceLookup&gt;

@end</code></pre></figure>

<p>And then we need to implement the single required method:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="cp">#pragma mark - SChartDatasourceLookup methods
</span><span class="k">-</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="nf">estimateYValueForXValue</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">xValue</span> <span class="nf">forSeriesAtIndex</span><span class="p">:(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">idx</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">([</span><span class="n">xValue</span> <span class="nf">isKindOfClass</span><span class="p">:[</span><span class="n">NSNumber</span> <span class="nf">class</span><span class="p">]])</span> <span class="p">{</span>
        <span class="c1">// Need it to be a date since we are comparing timestamp
</span>        <span class="n">xValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSDate</span> <span class="nf">dateWithTimeIntervalSince1970</span><span class="p">:[</span><span class="n">xValue</span> <span class="nf">doubleValue</span><span class="p">]];</span>
    <span class="p">}</span>
    <span class="n">NSArray</span> <span class="o">*</span><span class="n">xValues</span> <span class="o">=</span> <span class="p">[</span><span class="n">temperatureData</span><span class="p">.</span><span class="n">data</span> <span class="nf">valueForKeyPath</span><span class="p">:</span><span class="s">@"@unionOfObjects.timestamp"</span><span class="p">];</span>
    <span class="n">NSUInteger</span> <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">xValues</span> <span class="nf">indexOfBiggestObjectSmallerThan</span><span class="p">:</span><span class="n">xValue</span>
                                                  <span class="nf">inSortedRange</span><span class="p">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">xValues</span><span class="p">.</span><span class="n">count</span><span class="p">)];</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">TemperatureDataPoint</span><span class="o">*</span><span class="p">)</span><span class="n">temperatureData</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="nf">index</span><span class="p">]).</span><span class="n">temperature</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>This implementation performs the following operations:</p>

<ol>
  <li>We firstly make sure that we have been passed an object
of the correct type. We know that our x-values are timestamps, and are instances
of <code class="highlighter-rouge">NSDate</code>, however an <code class="highlighter-rouge">SChartAxis</code> returns its range with <code class="highlighter-rouge">NSNumber</code> types,
where the number represents the time interval since epoch. Therefore we perform
a simple type conversion to allow comparison with our source data.</li>
  <li>Construct an <code class="highlighter-rouge">NSArray</code> of all the x-values. With our data this can be achieved
by collecting the <code class="highlighter-rouge">timestamp</code> property from each data object.</li>
  <li>Now we search the x value array to find the index of the largest timestamp
smaller than the limit we have been provided. We do this with a method we’ve added
to <code class="highlighter-rouge">NSArray</code> via a category. We won’t go into great detail here about how it works
– the code is available in the repository if you wish to look it up. Note that
this assumes that the array of x-values is sorted with ascending order.</li>
  <li>Once we have this index we lookup the associated y-value (temperature) and
return it.</li>
</ol>

<h3 id="wiring-it-all-up">Wiring it all up</h3>

<p>We’ve now finished all the clever code - it just remains to wire it all up.</p>

<p>The <code class="highlighter-rouge">ShinobiRangeSelector</code> constructor now requires that the datasource object
conform to our new protocol, so we update as follows:</p>

<figure class="highlight"><pre><code class="language-shinobirangeselector.h" data-lang="shinobirangeselector.h">@interface ShinobiRangeSelector : UIView &lt;SChartDelegate&gt;

- (id)initWithFrame:(CGRect)frame
         datasource:(id&lt;SChartDatasource, SChartDatasourceLookup&gt;)datasource
    splitProportion:(CGFloat)proportion;

@end</code></pre></figure>

<p>and in the implementation file:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@interface</span> <span class="nc">ShinobiRangeSelector</span> <span class="p">()</span> <span class="o">&lt;</span><span class="n">ShinobiRangeAnnotationDelegate</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">id</span><span class="o">&lt;</span><span class="n">SChartDatasource</span><span class="p">,</span> <span class="n">SChartDatasourceLookup</span><span class="o">&gt;</span> <span class="n">chartDatasource</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">ShinobiRangeSelector</span>
<span class="k">-</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="nf">initWithFrame</span><span class="p">:(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">frame</span>
         <span class="nf">datasource</span><span class="p">:(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">SChartDatasource</span><span class="p">,</span> <span class="n">SChartDatasourceLookup</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">datasource</span>
    <span class="nf">splitProportion</span><span class="p">:(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">proportion</span>
<span class="p">{</span>
    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nf">initWithFrame</span><span class="p">:</span><span class="n">frame</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Initialization code
</span>        <span class="n">chartDatasource</span> <span class="o">=</span> <span class="n">datasource</span><span class="p">;</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="k">@end</span></code></pre></figure>

<p>We add creation of the value annotation manager to the existing main chart
initialisation method:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">createMainChartWithFrame</span><span class="p">:(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">frame</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">// Add some annotations
</span>    <span class="n">valueAnnotationManager</span> <span class="o">=</span> <span class="p">[[</span><span class="n">ShinobiValueAnnotationManager</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithChart</span><span class="p">:</span><span class="n">mainChart</span>
                                                                       <span class="nf">datasource</span><span class="p">:</span><span class="n">chartDatasource</span>
                                                                      <span class="nl">seriesIndex:</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">...</span>
<span class="p">}</span></code></pre></figure>

<p>The final piece of wiring up is to ensure that the value annotation gets updated
when the user interacts with the chart - which is a matter of calling the
<code class="highlighter-rouge">updateValueAnnotationForXAxisRange:</code> method:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">configureTheDefaultRange</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">// And update the annotation appropriately
</span>    <span class="p">...</span>
    <span class="p">[</span><span class="n">valueAnnotationManager</span> <span class="nf">updateValueAnnotationForXAxisRange</span><span class="p">:</span><span class="n">defaultRange</span><span class="p">];</span>
<span class="p">}</span>

<span class="cp">#pragma mark - ShinobiRangeSelectorDelegate methods
</span><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">rangeAnnotation</span><span class="o">:</span><span class="p">(</span><span class="n">ShinobiRangeAnnotationManager</span> <span class="o">*</span><span class="p">)</span><span class="n">annotation</span>
         <span class="n">didMoveToRange</span><span class="o">:</span><span class="p">(</span><span class="n">SChartRange</span> <span class="o">*</span><span class="p">)</span><span class="n">range</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">// Update the location of the annotation line
</span>    <span class="p">[</span><span class="n">valueAnnotationManager</span> <span class="nf">updateValueAnnotationForXAxisRange</span><span class="p">:</span><span class="n">range</span><span class="p">];</span>
    <span class="p">[</span><span class="n">mainChart</span> <span class="nf">redrawChart</span><span class="p">];</span>
<span class="p">}</span>


<span class="cp">#pragma mark - SChartDelegate methods
</span><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">sChartIsPanning</span><span class="o">:</span><span class="p">(</span><span class="n">ShinobiChart</span> <span class="o">*</span><span class="p">)</span><span class="n">chart</span> <span class="n">withChartMovementInformation</span><span class="o">:</span><span class="p">(</span><span class="k">const</span> <span class="n">SChartMovementInformation</span> <span class="o">*</span><span class="p">)</span><span class="n">information</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">rangeAnnotationManager</span> <span class="nf">moveRangeSelectorToRange</span><span class="p">:</span><span class="n">chart</span><span class="p">.</span><span class="n">xAxis</span><span class="p">.</span><span class="n">axisRange</span><span class="p">];</span>
    <span class="p">[</span><span class="n">valueAnnotationManager</span> <span class="nf">updateValueAnnotationForXAxisRange</span><span class="p">:</span><span class="n">chart</span><span class="p">.</span><span class="n">xAxis</span><span class="p">.</span><span class="n">axisRange</span><span class="p">];</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">sChartIsZooming</span><span class="o">:</span><span class="p">(</span><span class="n">ShinobiChart</span> <span class="o">*</span><span class="p">)</span><span class="n">chart</span> <span class="n">withChartMovementInformation</span><span class="o">:</span><span class="p">(</span><span class="k">const</span> <span class="n">SChartMovementInformation</span> <span class="o">*</span><span class="p">)</span><span class="n">information</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="p">[</span><span class="n">rangeAnnotationManager</span> <span class="nf">moveRangeSelectorToRange</span><span class="p">:</span><span class="n">chart</span><span class="p">.</span><span class="n">xAxis</span><span class="p">.</span><span class="n">axisRange</span><span class="p">];</span>
    <span class="p">[</span><span class="n">valueAnnotationManager</span> <span class="nf">updateValueAnnotationForXAxisRange</span><span class="p">:</span><span class="n">chart</span><span class="p">.</span><span class="n">xAxis</span><span class="p">.</span><span class="n">axisRange</span><span class="p">];</span>
<span class="p">}</span></code></pre></figure>

<p>With that we’re done!</p>

<p><img src="/images/2013-03-10-completed-annotations.png" alt="Completed Annotations" /></p>

<h2 id="conclusion">Conclusion</h2>

<p>Well, in the space of 4 blog posts we’ve built a charting application with some
really advanced functionality. We have 2 charts talking to each other with a range
selector annotation which moves with momentum, along with another annotation
which tracks the value of the rightmost datapoint visible on the chart.</p>

<p>As I mentioned at the top I’m expecting that this is last post in this blog series</p>
<ul>
  <li>I hope you’ve got a better understanding of quite how powerful ShinobiCharts
can be, and that you have got some ideas of apps of your own. If you have any
questions etc then leave a comment below or hit me up on twitter:
<a href="https://twitter.com/iwantmyrealname">@iwantmyrealname</a>.</li>
</ul>

<p>Don’t forget that the source code is available on GitHub at
<a href="https://github.com/sammyd/Shinobi-RangeSelector">github.com/sammyd/Shinobi-RangeSelector</a>
so you can grab it and play with it yourself. I will attempt to keep the source
code up to date with new releases of ShinobiCharts, and will push any bug fixes
that I find.</p>

<p>sx</p>

	  ]]></description>
	</item>

	<item>
	  <title>Building a range selector with ShinobiCharts: Part III - Adding momentum</title>
	  <link>/blog/2013/01/19/building-a-range-selector-with-shinobi-charts-part-iii-adding-momentum</link>
	  <author>Sam Davies</author>
	  <pubDate>2013-01-19T21:32:00+00:00</pubDate>
	  <guid>/blog/2013/01/19/building-a-range-selector-with-shinobi-charts-part-iii-adding-momentum</guid>
	  <description><![CDATA[
	     <blockquote>
  <p>This tutorial is also available on the <a href="http://www.shinobicontrols.com/blog/posts/2013/04/09/building-a-range-selector-with-shinobicharts-part-iii">ShinobiControls</a>
blog. You’ll find better support and assistance on this site as part of
<a href="http://www.shinobicontrols.com/shinobideveloper">ShinobiDeveloper</a></p>
</blockquote>

<p>This is the third post in a series about creating a range selector using Shinobi
charts for iOS. If you haven’t already read the previous posts
(<a href="/blog/2013/01/11/building-a-range-selector-with-shinobi-charts-part-i-linking-2-charts">part I</a>,
<a href="/blog/2013/01/15/building-a-range-selector-with-shinobi-charts-part-ii-creating-custom-handle-annotations">part II</a>)
I reckon that thisone will make a lot more sense if you do.</p>

<p>The code is available on github at
<a href="https://github.com/sammyd/Shinobi-RangeSelector">github.com/sammyd/Shinobi-RangeSelector</a>, and
combined with a copy of ShinobiCharts (or a 30-day demo) from
<a href="http://www.shinobicontrols.com/">shinobicontrols.com</a> you can get the entire
project up and running pretty quickly.</p>

<p>At this point in the project we’ve managed to create 2 charts, one of which
allows the user to interact with the data in the way we’d expect with an iOS chart,
and the other of which has a range selection annotation, which demonstrates which
section of the entire dataset the user is currently viewing. The user is able to
interact with the range selector to change the bounds of the main chart’s view,
as well as the location.</p>

<p>We left off last time with a bug (not really the best practice, but the post was
getting a bit on the long side), which would allow a user to drag the upper range
boundary below the lower:</p>

<p><img src="/images/2013-01-19-range-selector-broken.png" alt="Broken Range Selector" /></p>

<p>Let’s start off by fixing that, and then we’ll move on to looking at the altogether
more sexy problem of adding momentum to the range selector’s motion. Let’s stop
waffling and get coding…</p>

<!-- more -->

<h2 id="minimum-allowable-span">Minimum allowable span</h2>

<p>It wouldn’t be a difficult fix to just prevent a user from dragging the grippers
over the top of each other, but a much more elegant solution would be to have a
minimum span, below which the chart cannot be zoomed. This is useful for general
usage in ShinobiCharts - not just for a range selector. For example, if you have
data which you know is spaced one-per-day, then it doesn’t make sense for a user
to be able to zoom in to a range of 10 seconds - we’d like to set a minimum span
of say 1 week.</p>

<p>We need to address this issue in 2 places - one when the user interacts with the
main chart, and one with the range selector. We’ll start by looking at the main
chart.</p>

<h3 id="main-chart-interaction">Main chart interaction</h3>

<p>We’ll add an ivar to <code class="highlighter-rouge">ShinobiRangeSelector</code> which will contain the minimum allowed
span value:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@interface</span> <span class="nc">ShinobiRangeSelector</span> <span class="p">()</span> <span class="o">&lt;</span><span class="n">ShinobiRangeAnnotationDelegate</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">CGFloat</span> <span class="n">minimumSpan</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@end</span></code></pre></figure>

<p>For now, we just set this in the constructor. It might make more sense to pull
this out as a property later on.</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="nf">initWithFrame</span><span class="p">:(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">frame</span> <span class="nf">datasource</span><span class="p">:(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">SChartDatasource</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">datasource</span> <span class="nf">splitProportion</span><span class="p">:(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">proportion</span>
<span class="p">{</span>
    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nf">initWithFrame</span><span class="p">:</span><span class="n">frame</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    	<span class="p">...</span>
        <span class="c1">// Set a minimum span of 4 days
</span>        <span class="n">minimumSpan</span> <span class="o">=</span> <span class="mi">3600</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>In order to prevent the main chart from zooming below this range we can update the
<code class="highlighter-rouge">sChartIsZooming:withChartMovementInformation:</code> delegate method implementation
to check the range and reset it if it is smaller than our allowed range:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">sChartIsZooming</span><span class="p">:(</span><span class="n">ShinobiChart</span> <span class="o">*</span><span class="p">)</span><span class="nv">chart</span> <span class="nf">withChartMovementInformation</span><span class="p">:(</span><span class="k">const</span> <span class="n">SChartMovementInformation</span> <span class="o">*</span><span class="p">)</span><span class="nv">information</span>
<span class="p">{</span>
    <span class="c1">// We need to check that we haven't gone outside of our allowed span
</span>    <span class="k">if</span> <span class="p">([</span><span class="n">chart</span><span class="p">.</span><span class="n">xAxis</span><span class="p">.</span><span class="n">axisRange</span><span class="p">.</span><span class="n">span</span> <span class="nf">floatValue</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minimumSpan</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Re-zoom it
</span>        <span class="n">CGFloat</span> <span class="n">midValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">chart</span><span class="p">.</span><span class="n">xAxis</span><span class="p">.</span><span class="n">axisRange</span><span class="p">.</span><span class="n">span</span> <span class="nf">floatValue</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">[</span><span class="n">chart</span><span class="p">.</span><span class="n">xAxis</span><span class="p">.</span><span class="n">axisRange</span><span class="p">.</span><span class="n">minimum</span> <span class="nf">floatValue</span><span class="p">];</span>
        <span class="n">CGFloat</span> <span class="n">newMin</span> <span class="o">=</span> <span class="n">midValue</span> <span class="o">-</span> <span class="n">minimumSpan</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">CGFloat</span> <span class="n">newMax</span> <span class="o">=</span> <span class="n">midValue</span> <span class="o">+</span> <span class="n">minimumSpan</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">[</span><span class="n">chart</span><span class="p">.</span><span class="n">xAxis</span> <span class="nf">setRangeWithMinimum</span><span class="p">:</span><span class="err">@</span><span class="p">(</span><span class="n">newMin</span><span class="p">)</span> <span class="nf">andMaximum</span><span class="p">:</span><span class="err">@</span><span class="p">(</span><span class="n">newMax</span><span class="p">)];</span>
    <span class="p">}</span>
    <span class="p">[</span><span class="n">rangeAnnotationManager</span> <span class="nf">moveRangeSelectorToRange</span><span class="p">:</span><span class="n">chart</span><span class="p">.</span><span class="n">xAxis</span><span class="p">.</span><span class="n">axisRange</span><span class="p">];</span>
<span class="p">}</span></code></pre></figure>

<p>Here we check what the span is, and if it is smaller, then reset the span to the
minimum allowed, whilst maintaining the centre value.</p>

<h3 id="range-selector">Range selector</h3>

<p>We’ve now fixed it so that we can’t zoom in more than a specified amount by
interacting with the main chart, but it’s still possible to use the handles on
the range selector to bypass this.</p>

<p>We’ll start by adding a new constructor to the <code class="highlighter-rouge">ShinobiRangeAnnotationManager</code> to
pass in the minimum range, and an ivar to store it:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@interface</span> <span class="nc">ShinobiRangeAnnotationManager</span> <span class="p">:</span> <span class="nc">NSObject</span>
<span class="p">...</span>
<span class="o">-</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">initWithChart</span><span class="o">:</span><span class="p">(</span><span class="n">ShinobiChart</span> <span class="o">*</span><span class="p">)</span><span class="n">chart</span> <span class="n">minimumSpan</span><span class="o">:</span><span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="n">minSpan</span><span class="p">;</span>
<span class="k">@end</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@interface</span> <span class="nc">ShinobiRangeAnnotationManager</span> <span class="p">()</span><span class="o">&lt;</span><span class="n">UIGestureRecognizerDelegate</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">CGFloat</span> <span class="n">minimumSpan</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">ShinobiRangeAnnotationManager</span>
<span class="k">-</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="nf">initWithChart</span><span class="p">:(</span><span class="n">ShinobiChart</span> <span class="o">*</span><span class="p">)</span><span class="nv">_chart</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">self</span> <span class="nf">initWithChart</span><span class="p">:</span><span class="n">_chart</span> <span class="nf">minimumSpan</span><span class="p">:</span><span class="mi">3600</span><span class="o">*</span><span class="mi">24</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">-</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="nf">initWithChart</span><span class="p">:(</span><span class="n">ShinobiChart</span> <span class="o">*</span><span class="p">)</span><span class="nv">_chart</span> <span class="nf">minimumSpan</span><span class="p">:(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">minSpan</span>
<span class="p">{</span>
    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nf">init</span><span class="p">];</span>
    <span class="k">if</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">chart</span> <span class="o">=</span> <span class="n">_chart</span><span class="p">;</span>
        <span class="n">minimumSpan</span> <span class="o">=</span> <span class="n">minSpan</span><span class="p">;</span>
        <span class="p">[</span><span class="n">self</span> <span class="nf">createAnnotations</span><span class="p">];</span>
        <span class="p">[</span><span class="n">self</span> <span class="nf">prepareGestureRecognisers</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span></code></pre></figure>

<p>Notice that we keep our previous constructor, and chain them together, adding a
default value.</p>

<p>Now the only time we actually need to check that we haven’t broken this minimum
span restriction is when we’re dragging the handles on either side of the range
selector. This is all handled within the <code class="highlighter-rouge">handleGripperPan:</code> method, and so we
just need to update it to only allow the range to be updated if it doesn’t
violate this restriction:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">handleGripperPan</span><span class="p">:(</span><span class="n">UIPanGestureRecognizer</span><span class="o">*</span><span class="p">)</span><span class="nv">recogniser</span>
<span class="p">{</span>
    <span class="n">CGPoint</span> <span class="n">currentTouchPoint</span> <span class="o">=</span> <span class="p">[</span><span class="n">recogniser</span> <span class="nf">locationInView</span><span class="p">:</span><span class="n">chart</span><span class="p">.</span><span class="n">canvas</span><span class="p">];</span>
    
    <span class="c1">// What's the new location we've dragged the handle to?
</span>    <span class="kt">double</span> <span class="n">newValue</span> <span class="o">=</span> <span class="p">[[</span><span class="n">chart</span><span class="p">.</span><span class="n">xAxis</span> <span class="nf">estimateDataValueForPixelValue</span><span class="p">:</span><span class="n">currentTouchPoint</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="nf">doubleValue</span><span class="p">];</span>
    
    <span class="n">SChartRange</span> <span class="o">*</span><span class="n">newRange</span><span class="p">;</span>
    <span class="c1">// Update the range with the new value according to which handle we dragged
</span>    <span class="k">if</span><span class="p">(</span><span class="n">recogniser</span><span class="p">.</span><span class="n">view</span> <span class="o">==</span> <span class="n">leftGripper</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Left handle =&gt; change the range minimum
</span>        <span class="c1">// Check bounds
</span>        <span class="k">if</span><span class="p">([</span><span class="n">rightGripper</span><span class="p">.</span><span class="n">xValue</span> <span class="nf">floatValue</span><span class="p">]</span> <span class="o">-</span> <span class="n">newValue</span> <span class="o">&lt;</span> <span class="n">minimumSpan</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">newValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">rightGripper</span><span class="p">.</span><span class="n">xValue</span> <span class="nf">floatValue</span><span class="p">]</span> <span class="o">-</span> <span class="n">minimumSpan</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">newRange</span> <span class="o">=</span> <span class="p">[[</span><span class="n">SChartRange</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithMinimum</span><span class="p">:</span><span class="err">@</span><span class="p">(</span><span class="n">newValue</span><span class="p">)</span> <span class="nf">andMaximum</span><span class="p">:</span><span class="n">rightGripper</span><span class="p">.</span><span class="n">xValue</span><span class="p">];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// Right handle =&gt; change the range maximum
</span>        <span class="c1">// Check bounds
</span>        <span class="k">if</span><span class="p">(</span><span class="n">newValue</span> <span class="o">-</span> <span class="p">[</span><span class="n">leftGripper</span><span class="p">.</span><span class="n">xValue</span> <span class="nf">floatValue</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minimumSpan</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">newValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">leftGripper</span><span class="p">.</span><span class="n">xValue</span> <span class="nf">floatValue</span><span class="p">]</span> <span class="o">+</span> <span class="n">minimumSpan</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">newRange</span> <span class="o">=</span> <span class="p">[[</span><span class="n">SChartRange</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithMinimum</span><span class="p">:</span><span class="n">leftGripper</span><span class="p">.</span><span class="n">xValue</span> <span class="nf">andMaximum</span><span class="p">:</span><span class="err">@</span><span class="p">(</span><span class="n">newValue</span><span class="p">)];</span>
    <span class="p">}</span>
    
    <span class="c1">// Move the selector
</span>    <span class="p">[</span><span class="n">self</span> <span class="nf">moveRangeSelectorToRange</span><span class="p">:</span><span class="n">newRange</span><span class="p">];</span>
    
    <span class="c1">// And fire the delegate method
</span>    <span class="p">[</span><span class="n">self</span> <span class="nf">callRangeDidMoveDelegateWithRange</span><span class="p">:</span><span class="n">newRange</span><span class="p">];</span>
<span class="p">}</span></code></pre></figure>

<p>You can see that we’ve just added 2 conditional sections to this method - one for
each gripper. We check that we aren’t trying to make the range too small, and if
we are then simply reset it to the minimum range. This has the effect that as the
user drags the gripper it will appear to stop moving once the minimum span has
been reached. As they then drag back in the opposite direction, the range will
expand again, as expected.</p>

<p>In order to wire this up correctly, we just need to use the new constructor when
we create the annotation manager in <code class="highlighter-rouge">ShinobiRangeSelector</code>:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">createRangeChartWithFrame</span><span class="p">:(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">frame</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">// Add some annotations
</span>    <span class="n">rangeAnnotationManager</span> <span class="o">=</span> <span class="p">[[</span><span class="n">ShinobiRangeAnnotationManager</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithChart</span><span class="p">:</span><span class="n">rangeChart</span> <span class="nf">minimumSpan</span><span class="p">:</span><span class="n">minimumSpan</span><span class="p">];</span>
    <span class="n">rangeAnnotationManager</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span></code></pre></figure>

<h2 id="range-selector-momentum">Range selector momentum</h2>

<p>The other task I want to address in this post is adding momentum to the range
selector’s draggable motion. This means that when you let go of it, it shouldn’t
just stop dead, but should decelerate gracefully like dragging the main chart does.
Since we’re using anything which provides this, we’re going to roll our own
momentum animation - but don’t worry - it’s not as difficult as it sounds!</p>

<p>The way in which we wish the momentum animation to work is at the moment which
the user releases the range selector annotation from dragging, it should continue
to move in the same direction, with an appropriate deceleration curve. It’s easy
to find when a given gesture has been completed, so we simply need to write the
animation code.</p>

<h3 id="momentumanimation-utility-class">MomentumAnimation utility class</h3>

<p>We’ll create a utility class which will allow linear momentum animations. We’ll
aim to make this suitably generic, so create a simple class with one method:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@interface</span> <span class="nc">MomentumAnimation</span> <span class="p">:</span> <span class="nc">NSObject</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">animateWithStartPosition</span><span class="p">:(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">startPosition</span>
	               <span class="nf">startVelocity</span><span class="p">:(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">velocity</span>
	                    <span class="nf">duration</span><span class="p">:(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">duration</span>
	              <span class="nf">animationCurve</span><span class="p">:(</span><span class="n">SChartAnimationCurve</span><span class="p">)</span><span class="nv">curve</span>
	                 <span class="nf">updateBlock</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">CGFloat</span><span class="p">))</span><span class="nv">updateBlock</span><span class="p">;</span>

<span class="k">@end</span></code></pre></figure>

<p>Let’s break this down into the different parameters:</p>

<ul>
  <li><code class="highlighter-rouge">startPosition</code>: Since we’re creating a generic utility class, we’re going to
use normalised distance - in the range of [0,1]. In our particular scenario, we
will use 0 and 1 to represent the extrema on the range chart, and we’ll calculate
the value using the touch location at the instant the pan gesture is completed.</li>
  <li><code class="highlighter-rouge">startVelocity</code>: In order to get the get great user experience, we need to take
into account the speed with which the user is dragging when they let go of the
selector. If they user is dragging really slowly then the range selector should
travel less far than if they are dragging quickly - this is the conservation
of momentum. A pan gesture recogniser provides a velocity vector, but since our
animation is one dimensional, we only need a one dimensional velocity, with the
sign representing the direction.</li>
  <li><code class="highlighter-rouge">duration</code>: How long the animation should last in seconds.</li>
  <li><code class="highlighter-rouge">animationCurve</code>: We’ll get to this in more detail later on, but this determines
what shape the velocity-time curve should take. These are provided as utilities
by ShinobiCharts, and include decay, acceleration, linear and ease in/out.</li>
  <li><code class="highlighter-rouge">updateBlock</code>: Since we’re making a generic animation class, it won’t know how
to update the position in order to perform the animation. Therefore we provide a
block to allow the user to specify how to update positions. This block takes one
argument - a normalised position (i.e. in the same scale as the <code class="highlighter-rouge">startPosition</code>
parameter). As an alternative, we could define a delegate protocol, but I think
that a block is a bit cleaner for this use case.</li>
</ul>

<p>Note that in the implementation in the repo, we also provide some other
animation methods which provide default values for some of these parameters.</p>

<p>In the corresponding implementation for the animation method we save off some
ivars and define some additional ivars:</p>

<ul>
  <li><code class="highlighter-rouge">animating</code>: This boolean states whether or not the animation is currently
active. We’ll need this later on so that we can cancel animations should we
wish to.</li>
  <li><code class="highlighter-rouge">startPos</code> and <code class="highlighter-rouge">endPos</code>: The start and end positions for the animation. These
are calculated from the provided <code class="highlighter-rouge">startPosition</code>, <code class="highlighter-rouge">velocity</code> and <code class="highlighter-rouge">duration</code>
arguments. The equation for calculating the <code class="highlighter-rouge">startPos</code> is somewhat empirical - 
it all comes down to what ‘feels right’ when a user interacts with the app.
Note that we fix the positions to the [0,1] range we defined as our domain.</li>
</ul>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@interface</span> <span class="nc">MomentumAnimation</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">CGFloat</span> <span class="n">animationStartTime</span><span class="p">,</span> <span class="n">animationDuration</span><span class="p">;</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">positionUpdateBlock</span><span class="p">)(</span><span class="n">CGFloat</span><span class="p">);</span>
    <span class="n">CGFloat</span> <span class="n">startPos</span><span class="p">,</span> <span class="n">endPos</span><span class="p">;</span>
    <span class="n">BOOL</span> <span class="n">animating</span><span class="p">;</span>
    <span class="n">SChartAnimationCurve</span> <span class="n">animationCurve</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">MomentumAnimation</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">animateWithStartPosition</span><span class="p">:(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">startPosition</span>
			       <span class="nf">startVelocity</span><span class="p">:(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">velocity</span>
			            <span class="nf">duration</span><span class="p">:(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">duration</span>
			      <span class="nf">animationCurve</span><span class="p">:(</span><span class="n">SChartAnimationCurve</span><span class="p">)</span><span class="nv">curve</span>
			         <span class="nf">updateBlock</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">CGFloat</span><span class="p">))</span><span class="nv">updateBlock</span>
<span class="p">{</span>
    <span class="cm">/*
     Calculate the end position. The positions we are dealing with are proportions
     and as such are limited to the range [0,1]. The sign of the velocity is used
     to calculate the direction of the motion, and the magnitude represents how
     far we should expect to travel.
    */</span>
    <span class="n">endPos</span> <span class="o">=</span> <span class="n">startPosition</span> <span class="o">+</span> <span class="p">(</span><span class="n">velocity</span> <span class="o">*</span> <span class="n">duration</span><span class="p">)</span> <span class="o">/</span> <span class="mi">5</span><span class="p">;</span>
    
    <span class="c1">// Fix to the limits
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">endPos</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">endPos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">endPos</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">endPos</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// Save off the required variables as ivars
</span>    <span class="n">positionUpdateBlock</span> <span class="o">=</span> <span class="n">updateBlock</span><span class="p">;</span>
    <span class="n">startPos</span> <span class="o">=</span> <span class="n">startPosition</span><span class="p">;</span>
    
    <span class="c1">// Start an animation loop
</span>    <span class="n">animationStartTime</span> <span class="o">=</span> <span class="n">CACurrentMediaTime</span><span class="p">();</span>
    <span class="n">animationDuration</span> <span class="o">=</span> <span class="n">duration</span><span class="p">;</span>
    <span class="n">animationCurve</span> <span class="o">=</span> <span class="n">curve</span><span class="p">;</span>
    <span class="n">animating</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
    <span class="p">[</span><span class="n">self</span> <span class="nf">animationRecursion</span><span class="p">];</span>
<span class="p">}</span></code></pre></figure>

<p>The only other thing the API animation method does is to set some animation
values - the animation start time, and the animating boolean. It then calls the
<code class="highlighter-rouge">animationRecursion</code> method, the naming of which should give some idea as to how
we are going to perform the animation.</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">animationRecursion</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">CACurrentMediaTime</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">animationStartTime</span> <span class="o">+</span> <span class="n">animationDuration</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// We've finished the alloted animation time. Stop animating
</span>        <span class="n">animating</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">animating</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Let's update the position
</span>        <span class="n">CGFloat</span> <span class="n">currentTemporalProportion</span> <span class="o">=</span> <span class="p">(</span><span class="n">CACurrentMediaTime</span><span class="p">()</span> <span class="o">-</span> <span class="n">animationStartTime</span><span class="p">)</span> <span class="o">/</span> <span class="n">animationDuration</span><span class="p">;</span>
        <span class="n">CGFloat</span> <span class="n">currentSpatialProportion</span> <span class="o">=</span> <span class="p">[</span><span class="n">SChartAnimationCurveEvaluator</span> <span class="nf">evaluateCurve</span><span class="p">:</span><span class="n">animationCurve</span> <span class="nf">atPosition</span><span class="p">:</span><span class="n">currentTemporalProportion</span><span class="p">];</span>
        <span class="n">CGFloat</span> <span class="n">currentPosition</span> <span class="o">=</span> <span class="p">(</span><span class="n">endPos</span> <span class="o">-</span> <span class="n">startPos</span><span class="p">)</span> <span class="o">*</span> <span class="n">currentSpatialProportion</span> <span class="o">+</span> <span class="n">startPos</span><span class="p">;</span>
        
        <span class="c1">// Call the block which will perform the repositioning
</span>        <span class="n">positionUpdateBlock</span><span class="p">(</span><span class="n">currentPosition</span><span class="p">);</span>
        
        <span class="c1">// Recurse. We aim here for 20 updates per second.
</span>        <span class="p">[</span><span class="n">self</span> <span class="nf">performSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">animationRecursion</span><span class="p">)</span> <span class="nf">withObject</span><span class="p">:</span><span class="nb">nil</span> <span class="n">afterDelay</span><span class="o">:</span><span class="mi">0</span><span class="p">.</span><span class="mo">05</span><span class="n">f</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Let’s walk through what this method does:</p>

<ol>
  <li>Firstly we check whether the animation should have been completed - i.e. has
the specified time passed (<code class="highlighter-rouge">duration</code>) since the animation first began? If it has
then we should update the <code class="highlighter-rouge">animating</code> ivar accordingly.</li>
  <li>If the <code class="highlighter-rouge">animating</code> ivar is <code class="highlighter-rouge">NO</code> then we drop out of the end of this method - 
animation completed. Otherwise we continue.</li>
  <li>We need to update the position - this is where the aforementioned animation
curve comes into play. Shinobi provides a set of pre-defined animation curves,
and a class which can ‘evaluate’ them. Evaluation of a curve accepts a normalised
time value, and returns a normalised distance - i.e. we provide a curve type and
the proportion of the curve completed (in the temporal domain) and we will get
back a spatial proportion. We calculate the temporal completion proportion from
the current time, the start time and the duration. From this we get a spatial
proportion, which we need to map to the normalised space the momentum animation
is using. We do this with a simple linear mapping.</li>
  <li>We now need to actually update the position of the object we are moving, which
we do using the block. As specified, the block takes one variable - the normalised
distance we’ve just calculated. When we use the class we will define this block
ourselves.</li>
  <li>Finally we need to recurse - i.e. call ourselves again after a given time, so
that the position will be incrementally updated. Here we use a standard <code class="highlighter-rouge">NSObject</code>
method to delay a message send a given amount of time. Here we’ve gone with a
delay of 0.05s, which will represent a framerate of up to 20fps. We won’t get this
in reality, but the animation looks smooth enough at this rate.</li>
</ol>

<h3 id="using-the-momentumanumation-class">Using the MomentumAnumation class</h3>

<p>Now that we’ve gone to the effort of creating the <code class="highlighter-rouge">MomentumAnimation</code> class, we
should integrate it into the range selector code itself. We’ll create one
reusable instance of the animation class:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@interface</span> <span class="nc">ShinobiRangeAnnotationManager</span> <span class="p">()</span><span class="o">&lt;</span><span class="n">UIGestureRecognizerDelegate</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="p">...</span>
    <span class="n">MomentumAnimation</span> <span class="o">*</span><span class="n">momentumAnimation</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">ShinobiRangeAnnotationManager</span>
<span class="k">-</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="nf">initWithChart</span><span class="p">:(</span><span class="n">ShinobiChart</span> <span class="o">*</span><span class="p">)</span><span class="nv">_chart</span> <span class="nf">minimumSpan</span><span class="p">:(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">minSpan</span>
<span class="p">{</span>
    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nf">init</span><span class="p">];</span>
    <span class="k">if</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="c1">// Let's make an animation instance here. We'll use this whenever we need momentum
</span>        <span class="n">momentumAnimation</span> <span class="o">=</span> <span class="p">[</span><span class="n">MomentumAnimation</span> <span class="nf">new</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@end</span></code></pre></figure>

<p>The only place we want to use the animation is when the use stops dragging the
range annotation, so we only need to update the <code class="highlighter-rouge">handlePan:</code> method:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">handlePan</span><span class="p">:(</span><span class="n">UIPanGestureRecognizer</span><span class="o">*</span><span class="p">)</span><span class="nv">recogniser</span>
<span class="p">{</span>
    <span class="c1">// What's the pixel location of the touch?
</span>    <span class="n">CGPoint</span> <span class="n">currentTouchPoint</span> <span class="o">=</span> <span class="p">[</span><span class="n">recogniser</span> <span class="nf">locationInView</span><span class="p">:</span><span class="n">chart</span><span class="p">.</span><span class="n">canvas</span><span class="p">];</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">recogniser</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">UIGestureRecognizerStateEnded</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Work out some values required for the animation
</span>        <span class="c1">// startPosition is normalised so in range [0,1]
</span>        <span class="n">CGFloat</span> <span class="n">startPosition</span> <span class="o">=</span> <span class="n">currentTouchPoint</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">chart</span><span class="p">.</span><span class="n">canvas</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
        <span class="c1">// startVelocity should be normalised as well
</span>        <span class="n">CGFloat</span> <span class="n">startVelocity</span> <span class="o">=</span> <span class="p">[</span><span class="n">recogniser</span> <span class="nf">velocityInView</span><span class="p">:</span><span class="n">chart</span><span class="p">.</span><span class="n">canvas</span><span class="p">].</span><span class="n">x</span> <span class="o">/</span> <span class="n">chart</span><span class="p">.</span><span class="n">canvas</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>

        <span class="c1">// Use the momentum animator instance we have to start animating the annotation
</span>        <span class="p">[</span><span class="n">momentumAnimation</span> <span class="nf">animateWithStartPosition</span><span class="p">:</span><span class="n">startPosition</span>
                                      <span class="nf">startVelocity</span><span class="p">:</span><span class="n">startVelocity</span>
                                           <span class="nl">duration:</span><span class="mi">1</span><span class="p">.</span><span class="n">f</span>
                                     <span class="nl">animationCurve:</span><span class="n">SChartAnimationCurveEaseOut</span>
                                        <span class="nl">updateBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">CGFloat</span> <span class="n">position</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// This is the code which will get called to update the position
</span>            <span class="n">CGFloat</span> <span class="n">centrePixelLocation</span> <span class="o">=</span> <span class="n">position</span> <span class="o">*</span> <span class="n">chart</span><span class="p">.</span><span class="n">canvas</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
            
            <span class="c1">// Create the range
</span>            <span class="n">SChartRange</span> <span class="o">*</span><span class="n">updatedRange</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">rangeCentredOnPixelValue</span><span class="p">:</span><span class="n">centrePixelLocation</span><span class="p">];</span>
            
            <span class="c1">// Move the annotation to the correct location
</span>            <span class="p">[</span><span class="n">self</span> <span class="nf">moveRangeSelectorToRange</span><span class="p">:</span><span class="n">updatedRange</span><span class="p">];</span>
            
            <span class="c1">// And fire the delegate method
</span>            <span class="p">[</span><span class="n">self</span> <span class="nf">callRangeDidMoveDelegateWithRange</span><span class="p">:</span><span class="n">updatedRange</span><span class="p">];</span>
        <span class="p">}];</span>
        
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>                
        <span class="c1">// Create the range
</span>        <span class="n">SChartRange</span> <span class="o">*</span><span class="n">updatedRange</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">rangeCentredOnPixelValue</span><span class="p">:</span><span class="n">currentTouchPoint</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>
        
        <span class="c1">// Move the annotation to the correct location
</span>        <span class="p">[</span><span class="n">self</span> <span class="nf">moveRangeSelectorToRange</span><span class="p">:</span><span class="n">updatedRange</span><span class="p">];</span>
        
        <span class="c1">// And fire the delegate method
</span>        <span class="p">[</span><span class="n">self</span> <span class="nf">callRangeDidMoveDelegateWithRange</span><span class="p">:</span><span class="n">updatedRange</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Although this looks complicated, we haven’t really changed all that much from
the original implementation. We now check the state property of the gesture
recogniser - if the gesture has completed (<code class="highlighter-rouge">UIGestureRecognizerStateEnded</code>) then
we kick off the animation, otherwise, we do exactly as we did before.</p>

<p>In order to start the animation we need to normalise the position and the velocity,
which we do by dividing their pixel values by the width of the range chart’s
canvas. Then we invoke the animation method on the momentum animation object, 
passing the expected arguments. We’ve used <code class="highlighter-rouge">SChartAnimationCurveEaseOut</code> here as
that represents a pleasant deceleration. The block we pass in to update the
range selector position works as follows:</p>

<ol>
  <li>We calculate the new pixel location of the centre - this is multiplying the
normalised position by the width of the chart’s canvas.</li>
  <li>Then we use the utility method to calculate the new required range.</li>
  <li>This range is passed to the <code class="highlighter-rouge">moveRangeSelectorToRange:</code> method to update
the position of the</li>
  <li>And then finally we call the delegate method to make sure that the main chart
is updated as well.</li>
</ol>

<p>We’ve done all of these things before, in response to the direct user interaction
passed by the gesture recogniser. Here we are just replacing that with the
animation - really quite simple!</p>

<p>If you fire up the app now and play with it you’ll see that the momentum works
really rather well. Try dragging the range selector along at different speeds
and letting go - you’ll see the scrolling with momentum as we wanted.</p>

<h3 id="interacting-with-an-animating-property">Interacting with an animating property</h3>

<p>As ever, there’s a situation in which there is a problem. Once an animation starts
it will continue to update the position until the duration time has been completed.
If you attempt to interact with either the main chart, or the range selector whilst
this animation is happening, then the result with be a strange flickering, as
two different processes attempt to control the position of a single object
simultaneously. In order to fix this problem, we will provide a way of stopping
a currently running animation.</p>

<p>We add a simple method to the API of <code class="highlighter-rouge">MomentumAnimation</code>:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@interface</span> <span class="nc">MomentumAnimation</span> <span class="p">:</span> <span class="nc">NSObject</span>
<span class="p">...</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">stopAnimation</span><span class="p">;</span>
<span class="k">@end</span></code></pre></figure>

<p>Since we have the conditional check in the animation recursion method, stopping
the animation is really simple - we just have to set the <code class="highlighter-rouge">animating</code> ivar to
<code class="highlighter-rouge">NO</code>. Then on the next recursive call, we’ll just drop out of the loop:</p>

<figure class="highlight"><pre><code class="language-momentumanimation.m" data-lang="momentumanimation.m">@implementation MomentumAnimation
- (void)stopAnimation
{
    animating = NO;
}
@end</code></pre></figure>

<p>So when do we need to stop the animation? Well, it should be stopped every time
we change the range selector’s range, except those when we are animating.
We’re going to change the <code class="highlighter-rouge">moveRangeSelectorToRange:</code> method to include this
animation stopping functionality:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">moveRangeSelectorToRange</span><span class="p">:(</span><span class="n">SChartRange</span> <span class="o">*</span><span class="p">)</span><span class="nv">range</span> <span class="nf">cancelAnimation</span><span class="p">:(</span><span class="n">BOOL</span><span class="p">)</span><span class="nv">cancelAnimation</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cancelAnimation</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// In many cases we want to prevent the animation fighting with the UI
</span>        <span class="p">[</span><span class="n">momentumAnimation</span> <span class="nf">stopAnimation</span><span class="p">];</span>
    <span class="p">}</span>
    
    <span class="c1">// Update the positions of all the individual components which make up the
</span>    <span class="c1">// range annotation
</span>    <span class="n">leftLine</span><span class="p">.</span><span class="n">xValue</span> <span class="o">=</span> <span class="n">range</span><span class="p">.</span><span class="n">minimum</span><span class="p">;</span>
    <span class="n">rightLine</span><span class="p">.</span><span class="n">xValue</span> <span class="o">=</span> <span class="n">range</span><span class="p">.</span><span class="n">maximum</span><span class="p">;</span>
    <span class="n">leftShading</span><span class="p">.</span><span class="n">xValue</span> <span class="o">=</span> <span class="n">chart</span><span class="p">.</span><span class="n">xAxis</span><span class="p">.</span><span class="n">axisRange</span><span class="p">.</span><span class="n">minimum</span><span class="p">;</span>
    <span class="n">leftShading</span><span class="p">.</span><span class="n">xValueMax</span> <span class="o">=</span> <span class="n">range</span><span class="p">.</span><span class="n">minimum</span><span class="p">;</span>
    <span class="n">rightShading</span><span class="p">.</span><span class="n">xValue</span> <span class="o">=</span> <span class="n">range</span><span class="p">.</span><span class="n">maximum</span><span class="p">;</span>
    <span class="n">rightShading</span><span class="p">.</span><span class="n">xValueMax</span> <span class="o">=</span> <span class="n">chart</span><span class="p">.</span><span class="n">xAxis</span><span class="p">.</span><span class="n">axisRange</span><span class="p">.</span><span class="n">maximum</span><span class="p">;</span>
    <span class="n">leftGripper</span><span class="p">.</span><span class="n">xValue</span> <span class="o">=</span> <span class="n">range</span><span class="p">.</span><span class="n">minimum</span><span class="p">;</span>
    <span class="n">rightGripper</span><span class="p">.</span><span class="n">xValue</span> <span class="o">=</span> <span class="n">range</span><span class="p">.</span><span class="n">maximum</span><span class="p">;</span>
    <span class="n">rangeSelection</span><span class="p">.</span><span class="n">xValue</span> <span class="o">=</span> <span class="n">range</span><span class="p">.</span><span class="n">minimum</span><span class="p">;</span>
    <span class="n">rangeSelection</span><span class="p">.</span><span class="n">xValueMax</span> <span class="o">=</span> <span class="n">range</span><span class="p">.</span><span class="n">maximum</span><span class="p">;</span>
    
    <span class="c1">// And finally redraw the chart
</span>    <span class="p">[</span><span class="n">chart</span> <span class="nf">redrawChart</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">moveRangeSelectorToRange</span><span class="p">:(</span><span class="n">SChartRange</span> <span class="o">*</span><span class="p">)</span><span class="nv">range</span>
<span class="p">{</span>
    <span class="c1">// By default we'll cancel animations
</span>    <span class="p">[</span><span class="n">self</span> <span class="nf">moveRangeSelectorToRange</span><span class="p">:</span><span class="n">range</span> <span class="nf">cancelAnimation</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
<span class="p">}</span></code></pre></figure>

<p>We add the <code class="highlighter-rouge">cancelAnimation:</code> argument, which, if specified to be <code class="highlighter-rouge">YES</code> will send
the momentum animation ivar a <code class="highlighter-rouge">stopAnimation</code> method. The rest of the method
updates the annotation values as we were doing before.</p>

<p>We update the <code class="highlighter-rouge">moveRangeSelectorToRange:</code> method to call this new method with
<code class="highlighter-rouge">cancelAnimation</code> set to <code class="highlighter-rouge">YES</code>. This means that all the places we have used this
API method will now cancel animation before they try and update the position of
the range selector. This is fine and dandy for all but one place - in the position
update block for the animation itself. If we cancel the animation whilst animating
then it will never actually animate. Therefore we update the <code class="highlighter-rouge">updatePosition</code>
block as follows:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">handlePan</span><span class="p">:(</span><span class="n">UIPanGestureRecognizer</span><span class="o">*</span><span class="p">)</span><span class="nv">recogniser</span>
<span class="p">{</span>
	<span class="p">...</span>
    <span class="c1">// Use the momentum animator instance we have to start animating the annotation
</span>    <span class="p">[</span><span class="n">momentumAnimation</span> <span class="nf">animateWithStartPosition</span><span class="p">:</span><span class="n">startPosition</span>
                                  <span class="nf">startVelocity</span><span class="p">:</span><span class="n">startVelocity</span>
                                       <span class="nl">duration:</span><span class="mi">1</span><span class="p">.</span><span class="n">f</span>
                                 <span class="nl">animationCurve:</span><span class="n">SChartAnimationCurveEaseOut</span>
                                    <span class="nl">updateBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">CGFloat</span> <span class="n">position</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="c1">// Move the annotation to the correct location
</span>        <span class="c1">// We use the internal method so we don't kill the momentum animator
</span>        <span class="p">[</span><span class="n">self</span> <span class="nf">moveRangeSelectorToRange</span><span class="p">:</span><span class="n">updatedRange</span> <span class="nf">cancelAnimation</span><span class="p">:</span><span class="nb">NO</span><span class="p">];</span>
        <span class="p">...</span>
    <span class="p">}];</span>
    <span class="p">...</span>
<span class="p">}</span></code></pre></figure>

<p>Cool. Now if you run up the app again, then you will no longer get the jerky
motion when you try and interact during the momentum animation.</p>

<h2 id="onwards">Onwards</h2>

<p>So we’ve now added a minimum span to the range selector and momentum animation
for when the user is dragging it. We’ve pretty much got all the really cool
features which are in the ‘impress’ chart on ShinobiPlay - but there are a couple
of things to take a look at in the next post:</p>

<ul>
  <li>When we first start the app, we don’t have a nice default range. We’ll look
at how to set this.</li>
  <li>The other feature we’d like to add is the value annotation on the main chart.
This takes the form of a horizontal line which tracks the y-value of the right-
most visible point on the chart, along with a text label which specifies its
value.</li>
</ul>

<h3 id="update-20130310">Update 2013/03/10</h3>

<p>Removed use of internal ShinobiCharts methods in line with the code in the
repository.</p>


	  ]]></description>
	</item>

	<item>
	  <title>Building a range selector with ShinobiCharts: Part II - Creating custom handle annotations</title>
	  <link>/blog/2013/01/15/building-a-range-selector-with-shinobi-charts-part-ii-creating-custom-handle-annotations</link>
	  <author>Sam Davies</author>
	  <pubDate>2013-01-15T21:32:00+00:00</pubDate>
	  <guid>/blog/2013/01/15/building-a-range-selector-with-shinobi-charts-part-ii-creating-custom-handle-annotations</guid>
	  <description><![CDATA[
	     <blockquote>
  <p>This tutorial is also available on the <a href="http://www.shinobicontrols.com/blog/posts/2013/03/19/building-a-range-selector-with-shinobicharts-part-ii">ShinobiControls</a>
blog. You’ll find better support and assistance on this site as part of
<a href="http://www.shinobicontrols.com/shinobideveloper">ShinobiDeveloper</a></p>
</blockquote>

<p>In <a href="/blog/2013/01/11/building-a-range-selector-with-shinobi-charts-part-i-linking-2-charts">part one</a>,
we built a simple app which drew 2 charts from the same data source,
one of which allows user interaction, the other of which has an overlay which 
displays which region of the entire data set the main chart is currently displaying.
If you haven’t read/skimmed it I reckon this post will make a lot more sense if
you do that first. It’s pretty long, but is pretty approachable.</p>

<p>The first post laid a lot of the ground work upon which we can build cool things.
We’ve got some data and some charts, and a range selector annotation. In this post
we’re going to allow users to interact with the range annotation - so that dragging
it will update the range displayed within the main chart. Cool, let’s get on it.</p>

<p><img src="/images/2013-01-15-range-selector-wide.png" alt="Wide Range Selector" /></p>

<!-- more -->

<h2 id="interacting-with-the-range-selector">Interacting with the range selector</h2>

<p>We have already created a class to manage the range annotation, and most of the
work we’re going to be doing will be within that class. We want to be able to get
a user to interact with annotation, and usually in iOS we’d use gesture recognisers.
Helpfully, <code class="highlighter-rouge">SChartAnnotation</code> is a subclass of <code class="highlighter-rouge">UIView</code>, so all the gesture
magic we get from iOS we can use ourselves.</p>

<p>Our first interaction will be the ability for a user to drag the range annotation
along the range of the x-axis - using a pan gesture. The concept is simple - we will
add an invisible annotation to represent the selected range, and add a gesture
recogniser - however, there are a few nuances which we will have to address as we
go.</p>

<p>Let’s get started with creating the invisible annotation:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@interface</span> <span class="nc">ShinobiRangeAnnotationManager</span> <span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">SChartAnnotationZooming</span> <span class="o">*</span><span class="n">rangeSelection</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">createAnnotations</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">// The invisible range selection
</span>    <span class="n">rangeSelection</span> <span class="o">=</span> <span class="p">[[</span><span class="n">ShinobiRangeSelectionAnnotation</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithFrame</span><span class="p">:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="nf">xValue</span><span class="p">:</span><span class="n">chart</span><span class="p">.</span><span class="n">xAxis</span><span class="p">.</span><span class="n">axisRange</span><span class="p">.</span><span class="n">minimum</span> <span class="n">xValueMax</span><span class="o">:</span><span class="n">chart</span><span class="p">.</span><span class="n">xAxis</span><span class="p">.</span><span class="n">axisRange</span><span class="p">.</span><span class="n">maximum</span> <span class="n">xAxis</span><span class="o">:</span><span class="n">chart</span><span class="p">.</span><span class="n">xAxis</span> <span class="n">yAxis</span><span class="o">:</span><span class="n">chart</span><span class="p">.</span><span class="n">yAxis</span><span class="p">];</span>

    <span class="p">...</span>
    <span class="p">[</span><span class="n">chart</span> <span class="nf">addAnnotation</span><span class="p">:</span><span class="n">rangeSelection</span><span class="p">];</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">moveRangeSelectorToRange</span><span class="o">:</span><span class="p">(</span><span class="n">SChartRange</span> <span class="o">*</span><span class="p">)</span><span class="n">range</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="n">rangeSelection</span><span class="p">.</span><span class="n">xValue</span> <span class="o">=</span> <span class="n">range</span><span class="p">.</span><span class="n">minimum</span><span class="p">;</span>
    <span class="n">rangeSelection</span><span class="p">.</span><span class="n">xValueMax</span> <span class="o">=</span> <span class="n">range</span><span class="p">.</span><span class="n">maximum</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span></code></pre></figure>

<p>We’ve added a new ivar to keep hold of our new annotation, and then we’ve created
the annotation itself. We also update the limits of the annotation in our API method
which is called when the user interacts with the main chart.</p>

<p>You might however have noticed that we aren’t creating this annotation in the
same way we have created the lines and the shaded regions. We have instead created
our own <code class="highlighter-rouge">SChartAnnotation</code> subclass instead, and this is due to the way in which
annotations work internally.</p>

<p>When an annotation is created, it is generally created with a size of 1x1. Then,
when the annotations size is required to change, it has its <code class="highlighter-rouge">transform</code> property
updated with an appropriate affine transform to get it to display as required.
This works great for general annotations, but it has the side-effect that a pan
gesture recogniser won’t get triggered within it - the most you can drag is 1pt</p>
<ul>
  <li>not enough to be recognised as a pan. Therefore we create our own subclass of
<code class="highlighter-rouge">SChartAnnotationZooming</code> which will change this behaviour:</li>
</ul>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@interface</span> <span class="nc">ShinobiRangeSelectionAnnotation</span> <span class="p">:</span> <span class="nc">SChartAnnotationZooming</span>
<span class="k">-</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="nf">initWithFrame</span><span class="p">:(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">frame</span> <span class="nf">xValue</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">xValue</span> <span class="nf">xValueMax</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">xValueMax</span> <span class="nf">xAxis</span><span class="p">:(</span><span class="n">SChartAxis</span><span class="o">*</span><span class="p">)</span><span class="nv">xAxis</span> <span class="nf">yAxis</span><span class="p">:(</span><span class="n">SChartAxis</span><span class="o">*</span><span class="p">)</span><span class="nv">yAxis</span><span class="p">;</span>
<span class="k">@end</span></code></pre></figure>

<p>The constructor has the arguments we need to set up the <code class="highlighter-rouge">SChartAnnotationZooming</code>
superclass, which is as expected:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@implementation</span> <span class="nc">ShinobiRangeSelectionAnnotation</span>

<span class="k">-</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="nf">initWithFrame</span><span class="p">:(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">frame</span> <span class="nf">xValue</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">xValue</span> <span class="nf">xValueMax</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">xValueMax</span> <span class="nf">xAxis</span><span class="p">:(</span><span class="n">SChartAxis</span> <span class="o">*</span><span class="p">)</span><span class="nv">xAxis</span> <span class="nf">yAxis</span><span class="p">:(</span><span class="n">SChartAxis</span> <span class="o">*</span><span class="p">)</span><span class="nv">yAxis</span>
<span class="p">{</span>
    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nf">initWithFrame</span><span class="p">:</span><span class="n">frame</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Initialization code
</span>        <span class="n">self</span><span class="p">.</span><span class="n">xAxis</span> <span class="o">=</span> <span class="n">xAxis</span><span class="p">;</span>
        <span class="n">self</span><span class="p">.</span><span class="n">yAxis</span> <span class="o">=</span> <span class="n">yAxis</span><span class="p">;</span>
        <span class="n">self</span><span class="p">.</span><span class="n">yValue</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
        <span class="n">self</span><span class="p">.</span><span class="n">yValueMax</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
        <span class="n">self</span><span class="p">.</span><span class="n">xValue</span> <span class="o">=</span> <span class="n">xValue</span><span class="p">;</span>
        <span class="n">self</span><span class="p">.</span><span class="n">xValueMax</span> <span class="o">=</span> <span class="n">xValueMax</span><span class="p">;</span>
        <span class="n">self</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="nf">clearColor</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@end</span></code></pre></figure>

<p>Then we need to override 2 <code class="highlighter-rouge">UIView</code> methods. <code class="highlighter-rouge">setTransform:</code> is called by the
ShinobiCharts framework when the x and y limit values associated with the
annotation are changed, or when the chart is zoomed. Only the former of these
situations applies to us here, and since we are displaying a completely transparent
view (remember it is only there as a gesture target) we prevent the transform from
being set, and instead change the frame size. This is actually really simple, and
doesn’t require any clever calculation. If we were displaying something in our
annotation, and allowing chart zooming, then we would have to think about this in
more detail, but the following is fine for now:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setTransform</span><span class="p">:(</span><span class="n">CGAffineTransform</span><span class="p">)</span><span class="nv">transform</span>
<span class="p">{</span>
    <span class="c1">// Zooming annotations usually use an affine transform to set their shape.
</span>    <span class="c1">//  We're going to change the frame of the annotation so that we have a
</span>    <span class="c1">//  suitable area to which to recognise dragging gestures.
</span>    <span class="n">CGRect</span> <span class="n">bds</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">;</span>
    <span class="n">bds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">*=</span> <span class="n">transform</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
    <span class="n">bds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">*=</span> <span class="n">transform</span><span class="p">.</span><span class="n">d</span><span class="p">;</span>
    <span class="n">self</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">bds</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>The other method we override is <code class="highlighter-rouge">layoutSubviews</code>, and we do this to ensure that
the height of our annotation is the same as the y-axis. We do this in this method
to ensure that if our chart changes size then the annotation will scale vertically
as appropriate:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">layoutSubviews</span>
<span class="p">{</span>
    <span class="c1">// We force the height to be that of the y-axis itself
</span>    <span class="n">CGRect</span> <span class="n">bds</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">;</span>
    <span class="n">bds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">yAxis</span><span class="p">.</span><span class="n">axisFrame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
    <span class="n">self</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">bds</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<h2 id="adding-gestures">Adding gestures</h2>

<p>Now that we’ve got our invisible annotation as a touch target, we can add the
a pan gesture:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="nf">initWithChart</span><span class="p">:(</span><span class="n">ShinobiChart</span> <span class="o">*</span><span class="p">)</span><span class="nv">_chart</span>
<span class="p">{</span>
    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nf">init</span><span class="p">];</span>
    <span class="k">if</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="p">[</span><span class="n">self</span> <span class="nf">prepareGestureRecognisers</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">prepareGestureRecognisers</span>
<span class="p">{</span>
    <span class="c1">// We need to stop other subviews of the chart from intercepting touches
</span>    <span class="n">chart</span><span class="p">.</span><span class="n">userInteractionEnabled</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">UIView</span> <span class="o">*</span><span class="n">v</span> <span class="k">in</span> <span class="n">chart</span><span class="p">.</span><span class="n">subviews</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">v</span><span class="p">.</span><span class="n">userInteractionEnabled</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">chart</span><span class="p">.</span><span class="n">canvas</span><span class="p">.</span><span class="n">userInteractionEnabled</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">UIView</span> <span class="o">*</span><span class="n">v</span> <span class="k">in</span> <span class="n">chart</span><span class="p">.</span><span class="n">canvas</span><span class="p">.</span><span class="n">subviews</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">v</span><span class="p">.</span><span class="n">userInteractionEnabled</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">chart</span><span class="p">.</span><span class="n">canvas</span><span class="p">.</span><span class="n">glView</span><span class="p">.</span><span class="n">userInteractionEnabled</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
    
    <span class="c1">// Add a pan gesture recogniser for dragging the range selector
</span>    <span class="n">UIPanGestureRecognizer</span> <span class="o">*</span><span class="n">gestureRecogniser</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIPanGestureRecognizer</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithTarget</span><span class="p">:</span><span class="n">self</span> <span class="nf">action</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">handlePan</span><span class="o">:</span><span class="p">)];</span>
    <span class="p">[</span><span class="n">rangeSelection</span> <span class="nf">addGestureRecognizer</span><span class="p">:</span><span class="n">gestureRecogniser</span><span class="p">];</span>
<span class="p">}</span></code></pre></figure>

<p>We add a new method to the annotation manager which will create the gesture
recognisers and add them to the annotation. The last 2 lines of this
<code class="highlighter-rouge">prepareGestureRecognisers</code> method does just that - standard <code class="highlighter-rouge">UIGestureRecognizer</code>
usage. However, before that there is some more ShinobiChart internal magic.</p>

<p>In order that gesture recognisers work, their entire parent view hierarchy has to
have <code class="highlighter-rouge">userInteractionEnabled = YES;</code>. Because of where annotations appear within
the view hierarchy, this isn’t true by default. Therefore the first part of the
<code class="highlighter-rouge">prepareGestureRecognisers</code> method ensures that this property is set correctly
for our annotation to be able to receive gestures. Annotations appear on the
<code class="highlighter-rouge">glView</code> subview of the <code class="highlighter-rouge">canvas</code> of a chart by default, so we make sure that all
of these behave as expected. Note, in order to get access to subviews of the canvas
layer you’ll have to import the <code class="highlighter-rouge">SChartCanvas</code> header:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="cp">#import &lt;ShinobiCharts/SChartCanvas.h&gt;</span></code></pre></figure>

<p>When we created the gesture, we said that the handler would be called <code class="highlighter-rouge">handlePan:</code>,
so we should implement that:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="cp">#pragma mark - Gesture events
</span><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">handlePan</span><span class="p">:(</span><span class="n">UIPanGestureRecognizer</span><span class="o">*</span><span class="p">)</span><span class="nv">recogniser</span>
<span class="p">{</span>
    <span class="c1">// What's the pixel location of the touch?
</span>    <span class="n">CGPoint</span> <span class="n">currentTouchPoint</span> <span class="o">=</span> <span class="p">[</span><span class="n">recogniser</span> <span class="nf">locationInView</span><span class="p">:</span><span class="n">chart</span><span class="p">.</span><span class="n">canvas</span><span class="p">.</span><span class="n">glView</span><span class="p">];</span>
                   
    <span class="c1">// Create the range
</span>    <span class="n">SChartRange</span> <span class="o">*</span><span class="n">updatedRange</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">rangeCentredOnPixelValue</span><span class="p">:</span><span class="n">currentTouchPoint</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>
    
    <span class="c1">// Move the annotation to the correct location
</span>    <span class="p">[</span><span class="n">self</span> <span class="nf">moveRangeSelectorToRange</span><span class="p">:</span><span class="n">updatedRange</span><span class="p">];</span>
<span class="p">}</span>

<span class="cp">#pragma mark - Utility methods
</span><span class="k">-</span> <span class="p">(</span><span class="n">SChartRange</span><span class="o">*</span><span class="p">)</span><span class="nf">rangeCentredOnPixelValue</span><span class="p">:(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">pixelValue</span>
<span class="p">{</span>
    <span class="c1">// Find the extent of the current range
</span>    <span class="kt">double</span> <span class="n">range</span> <span class="o">=</span> <span class="p">[</span><span class="n">rightLine</span><span class="p">.</span><span class="n">xValue</span> <span class="nf">doubleValue</span><span class="p">]</span> <span class="o">-</span> <span class="p">[</span><span class="n">leftLine</span><span class="p">.</span><span class="n">xValue</span> <span class="nf">doubleValue</span><span class="p">];</span>
    <span class="c1">// Find the new centre location
</span>    <span class="kt">double</span> <span class="n">newCentreValue</span> <span class="o">=</span> <span class="p">[[</span><span class="n">chart</span><span class="p">.</span><span class="n">xAxis</span> <span class="nf">estimateDataValueForPixelValue</span><span class="p">:</span><span class="n">pixelValue</span><span class="p">]</span> <span class="nf">doubleValue</span><span class="p">];</span>
    <span class="c1">// Calculate the new limits
</span>    <span class="kt">double</span> <span class="n">newMin</span> <span class="o">=</span> <span class="n">newCentreValue</span> <span class="o">-</span> <span class="n">range</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">newMax</span> <span class="o">=</span> <span class="n">newCentreValue</span> <span class="o">+</span> <span class="n">range</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
    
    <span class="c1">// Create the range and return it
</span>    <span class="k">return</span> <span class="p">[[</span><span class="n">SChartRange</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithMinimum</span><span class="p">:</span><span class="err">@</span><span class="p">(</span><span class="n">newMin</span><span class="p">)</span> <span class="nf">andMaximum</span><span class="p">:</span><span class="err">@</span><span class="p">(</span><span class="n">newMax</span><span class="p">)];</span>
<span class="p">}</span></code></pre></figure>

<p>The gesture callback itself is pretty simple because we’ve farmed out the mildly-
complicated calculation to a helper method. We’ll discuss that in a sec, but first
just run through the <code class="highlighter-rouge">handlePan:</code> method. Firstly we use standard <code class="highlighter-rouge">UIGestureReconizer</code>
properties to find the pixel location of the touch in the chart’s canvas. Then,
using our helper method we find out what range this touch point should represent,
before calling our previously created method to update the range selector’s location.</p>

<p>We use the <code class="highlighter-rouge">rangeCentredOnPixelValue:</code> method to find where we should move the
range selector to, given that it should be centred on a particular pixel (well,
pixel x-value). Most of this is self-explanatory, apart from the line which defines
and new variable called <code class="highlighter-rouge">newCentreValue</code>. This is another little bit of Shinobi
magic, so I’ll explain this in a little more detail.</p>

<p>In order to convert a touch point in pixels on a chart to an underlying data point
we add a category on <code class="highlighter-rouge">SChartAxis</code> which provides a new method to perform this
calculation:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@interface</span> <span class="nc">SChartAxis</span> <span class="p">(</span><span class="nl">CoordinateSpaceConversion</span><span class="p">)</span>
<span class="k">-</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="nf">estimateDataValueForPixelValue</span><span class="p">:(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">pixelValue</span><span class="p">;</span>
<span class="k">@end</span></code></pre></figure>

<p>The implementation of this method is as follows:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@implementation</span> <span class="nc">SChartAxis</span> <span class="p">(</span><span class="nl">CoordinateSpaceConversion</span><span class="p">)</span>
<span class="k">-</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="nf">estimateDataValueForPixelValue</span><span class="p">:(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">pixelValue</span>
<span class="p">{</span>
    <span class="c1">// What is the axis range?
</span>    <span class="n">SChartRange</span> <span class="o">*</span><span class="n">range</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">axisRange</span><span class="p">;</span>
    
    <span class="c1">// What's the frame of the plot area
</span>    <span class="n">CGRect</span> <span class="n">glFrame</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">chart</span><span class="p">.</span><span class="n">canvas</span><span class="p">.</span><span class="n">glView</span><span class="p">.</span><span class="n">bounds</span><span class="p">;</span>
    
    <span class="c1">// 
</span>    <span class="n">CGFloat</span> <span class="n">pixelSpan</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">axisOrientation</span> <span class="o">==</span> <span class="n">SChartOrientationHorizontal</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pixelSpan</span> <span class="o">=</span> <span class="n">glFrame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">pixelSpan</span> <span class="o">=</span> <span class="n">glFrame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// Assuming that there is a linear map
</span>    <span class="c1">// NOTE :: This won't work for discontinuous or logarithmic axes
</span>    <span class="k">return</span> <span class="err">@</span><span class="p">(</span> <span class="p">[</span><span class="n">range</span><span class="p">.</span><span class="n">span</span> <span class="nf">doubleValue</span><span class="p">]</span> <span class="o">/</span> <span class="n">pixelSpan</span> <span class="o">*</span> <span class="n">pixelValue</span> <span class="o">+</span> <span class="p">[</span><span class="n">range</span><span class="p">.</span><span class="n">minimum</span> <span class="nf">doubleValue</span><span class="p">]</span> <span class="p">);</span>
<span class="p">}</span>
<span class="k">@end</span></code></pre></figure>

<p>We find the current displayed range of the axis, and the size in pixels of the
chart. Provided that the axis isn’t logarithmic or discontinuous, then there is
a linear relationship between the data range and the width in pixels. We simply
calculate the data value using this linear relationship:</p>

<script type="math/tex; mode=display">val_{data} = \frac{span_{data}}{span_{pixel}} \cdot val_{pixel} + min_{data}</script>

<h2 id="linking-back-to-the-main-chart">Linking back to the main chart</h2>

<p>So now, if you fire up your app, you should have a range selector which you can
drag across the range chart - pretty neat eh? But as you drag it, the main chart
isn’t updated as we would expect. So let’s fix that.</p>

<p>We’ll create a new delegate protocol which the annotation manager will use to
inform interested parties that the range annotation has moved:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@protocol</span> <span class="nc">ShinobiRangeAnnotationDelegate</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span>

<span class="err">@required</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">rangeAnnotation</span><span class="o">:</span><span class="p">(</span><span class="n">ShinobiRangeAnnotationManager</span><span class="o">*</span><span class="p">)</span><span class="n">annotation</span> <span class="n">didMoveToRange</span><span class="o">:</span><span class="p">(</span><span class="n">SChartRange</span><span class="o">*</span><span class="p">)</span><span class="n">range</span><span class="p">;</span>

<span class="k">@end</span></code></pre></figure>

<p>We’ll make our <code class="highlighter-rouge">ShinobiRangeSelector</code> adopt this protocol:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@interface</span> <span class="nc">ShinobiRangeSelector</span> <span class="p">()</span> <span class="o">&lt;</span><span class="n">ShinobiRangeAnnotationDelegate</span><span class="o">&gt;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">ShinobiRangeSelector</span>
<span class="cp">#pragma mark - ShinobiRangeSelectorDelegate methods
</span><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">rangeAnnotation</span><span class="p">:(</span><span class="n">ShinobiRangeAnnotationManager</span> <span class="o">*</span><span class="p">)</span><span class="nv">annotation</span> <span class="nf">didMoveToRange</span><span class="p">:(</span><span class="n">SChartRange</span> <span class="o">*</span><span class="p">)</span><span class="nv">range</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">mainChart</span><span class="p">.</span><span class="n">xAxis</span> <span class="nf">setRangeWithMinimum</span><span class="p">:</span><span class="n">range</span><span class="p">.</span><span class="n">minimum</span> <span class="nf">andMaximum</span><span class="p">:</span><span class="n">range</span><span class="p">.</span><span class="n">maximum</span><span class="p">];</span>
    <span class="p">[</span><span class="n">mainChart</span> <span class="nf">redrawChart</span><span class="p">];</span>
<span class="p">}</span>
<span class="k">@end</span></code></pre></figure>

<p>Really nice and simple - when the method is called, we update the range
on the x-axis of the main chart to show the specified range, and redraw the chart.</p>

<p>Now we need to ensure that the delegate method is called appropriately. We add
a <code class="highlighter-rouge">delegate</code> property to the annotation manager:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@interface</span> <span class="nc">ShinobiRangeAnnotationManager</span> <span class="p">:</span> <span class="nc">NSObject</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">id</span><span class="o">&lt;</span><span class="n">ShinobiRangeAnnotationDelegate</span><span class="o">&gt;</span> <span class="n">delegate</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">@end</span></code></pre></figure>

<p>And then add a utility method to the implementation to call the delegate method.
This isn’t vital at this stage as we’re only going to call the delegate method
in one place, however, in later parts of this project we’ll be adding other calls:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">callRangeDidMoveDelegateWithRange</span><span class="p">:(</span><span class="n">SChartRange</span><span class="o">*</span><span class="p">)</span><span class="nv">range</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">delegate</span> <span class="o">&amp;&amp;</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">delegate</span> <span class="nf">respondsToSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nf">rangeAnnotation</span><span class="p">:</span><span class="n">didMoveToRange</span><span class="o">:</span><span class="p">)])</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">delegate</span> <span class="nf">rangeAnnotation</span><span class="p">:</span><span class="n">self</span> <span class="nf">didMoveToRange</span><span class="p">:</span><span class="n">range</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>We call this utility method as part of <code class="highlighter-rouge">handlePan:</code>, i.e. when the pan gesture we
created before is fired:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">handlePan</span><span class="p">:(</span><span class="n">UIPanGestureRecognizer</span><span class="o">*</span><span class="p">)</span><span class="nv">recogniser</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">// And fire the delegate method
</span>    <span class="p">[</span><span class="n">self</span> <span class="nf">callRangeDidMoveDelegateWithRange</span><span class="p">:</span><span class="n">updatedRange</span><span class="p">];</span>
<span class="p">}</span></code></pre></figure>

<p>The last thing to do (actually, the thing I always forget to do when creating
delegates) is to make sure that the have assigned the delegate property on the
annotation manager when we create it:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">createRangeChartWithFrame</span><span class="p">:(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">frame</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="n">rangeAnnotationManager</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span></code></pre></figure>

<p>Since we’ve already implemented the required delegate methods, when we fire the
app up now, we should have the behaviour we wanted - when you drag the range
selector, the main chart scrolls with you. That’s really cool, but we’re not done
yet…</p>

<h2 id="adding-handles-to-the-range-selector">Adding handles to the range selector</h2>

<p>Although we can pan the range selector, ideally we would be able to change the
length of the selection as well. To do this we’ll add some handle annotations to
the ends of the range selector, and add gesture recognisers to them, so that the
user can grab hold of one of them and drag it to change the end point of the range.</p>

<p><img src="/images/2013-01-15-range-selector-handles.png" alt="Range Selector Handles" /></p>

<p>We’ll create the handle as a custom <code class="highlighter-rouge">SChartAnnotation</code> subclass:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@interface</span> <span class="nc">ShinobiRangeHandleAnnotation</span> <span class="p">:</span> <span class="nc">SChartAnnotation</span>
<span class="k">-</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="nf">initWithFrame</span><span class="p">:(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">frame</span> <span class="nf">colour</span><span class="p">:(</span><span class="n">UIColor</span><span class="o">*</span><span class="p">)</span><span class="nv">colour</span> <span class="nf">xValue</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">xValue</span> <span class="nf">xAxis</span><span class="p">:(</span><span class="n">SChartAxis</span> <span class="o">*</span><span class="p">)</span><span class="nv">xAxis</span> <span class="nf">yAxis</span><span class="p">:(</span><span class="n">SChartAxis</span><span class="o">*</span><span class="p">)</span><span class="nv">yAxis</span><span class="p">;</span>
<span class="k">@end</span></code></pre></figure>

<p>In a similar way to the previous custom annotation we made we create a constructor
which then sets all the required properties:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@implementation</span> <span class="nc">ShinobiRangeHandleAnnotation</span>

<span class="k">-</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="nf">initWithFrame</span><span class="p">:(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">frame</span> <span class="nf">colour</span><span class="p">:(</span><span class="n">UIColor</span> <span class="o">*</span><span class="p">)</span><span class="nv">colour</span> <span class="nf">xValue</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">xValue</span> <span class="nf">xAxis</span><span class="p">:(</span><span class="n">SChartAxis</span> <span class="o">*</span><span class="p">)</span><span class="nv">xAxis</span> <span class="nf">yAxis</span><span class="p">:(</span><span class="n">SChartAxis</span> <span class="o">*</span><span class="p">)</span><span class="nv">yAxis</span>
<span class="p">{</span>
    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nf">initWithFrame</span><span class="p">:</span><span class="n">frame</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Initialization code
</span>        <span class="n">self</span><span class="p">.</span><span class="n">xAxis</span> <span class="o">=</span> <span class="n">xAxis</span><span class="p">;</span>
        <span class="n">self</span><span class="p">.</span><span class="n">yAxis</span> <span class="o">=</span> <span class="n">yAxis</span><span class="p">;</span>
        <span class="n">self</span><span class="p">.</span><span class="n">xValue</span> <span class="o">=</span> <span class="n">xValue</span><span class="p">;</span>
        <span class="c1">// Setting this to nil will ensure that the handle appears in the centre
</span>        <span class="n">self</span><span class="p">.</span><span class="n">yValue</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
        
        <span class="p">[</span><span class="n">self</span> <span class="nf">drawHandleWithColour</span><span class="p">:</span><span class="n">colour</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@end</span></code></pre></figure>

<p>The only interesting part of this is that setting the <code class="highlighter-rouge">yValue</code> property to <code class="highlighter-rouge">nil</code>
will ensure that the handle will be drawn vertically centred - which is perfect
for our purposes. We have defined a custom method <code class="highlighter-rouge">drawHandleWithColour:</code> which
actually creates the handle:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">drawHandleWithColour</span><span class="p">:(</span><span class="n">UIColor</span> <span class="o">*</span><span class="p">)</span><span class="nv">colour</span>
<span class="p">{</span>
    <span class="n">self</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="n">self</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="n">colour</span><span class="p">;</span>
    
    <span class="c1">// Add 3 lines
</span>    <span class="kt">int</span> <span class="n">numberLines</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">CGFloat</span> <span class="n">lineWidth</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">CGFloat</span> <span class="n">lineSpacing</span> <span class="o">=</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">-</span> <span class="n">lineWidth</span> <span class="o">*</span> <span class="n">numberLines</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">numberLines</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">CGFloat</span> <span class="n">heightProportion</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">6</span><span class="p">;</span>
    <span class="n">CGFloat</span> <span class="n">lineHeight</span> <span class="o">=</span> <span class="n">heightProportion</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
    <span class="n">CGFloat</span> <span class="n">lineY</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">heightProportion</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
    <span class="n">CGFloat</span> <span class="n">currentOffset</span> <span class="o">=</span> <span class="n">lineSpacing</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">numberLines</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">UIView</span> <span class="o">*</span><span class="n">newLine</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIView</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithFrame</span><span class="p">:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="n">currentOffset</span><span class="p">,</span> <span class="n">lineY</span><span class="p">,</span> <span class="n">lineWidth</span><span class="p">,</span> <span class="n">lineHeight</span><span class="p">)];</span>
        <span class="n">newLine</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="nf">colorWithWhite</span><span class="p">:</span><span class="mi">1</span><span class="p">.</span><span class="n">f</span> <span class="nf">alpha</span><span class="p">:</span><span class="mi">0</span><span class="p">.</span><span class="mi">7</span><span class="n">f</span><span class="p">];</span>
        <span class="p">[</span><span class="n">self</span> <span class="nf">addSubview</span><span class="p">:</span><span class="n">newLine</span><span class="p">];</span>
        <span class="n">currentOffset</span> <span class="o">+=</span> <span class="p">(</span><span class="n">lineWidth</span> <span class="o">+</span> <span class="n">lineSpacing</span><span class="p">);</span>
    <span class="p">}</span>   
<span class="p">}</span></code></pre></figure>

<p>This is all standard <code class="highlighter-rouge">UIView</code> code. In order to set the corners to be rounded
you need to have imported <code class="highlighter-rouge">QuartzCore.h</code>:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="cp">#import &lt;QuartzCore/QuartzCore.h&gt;</span></code></pre></figure>

<p>We do some trivial calculations to draw 3 evenly spaced vertical lines within the
handle view to give a more traditional gripper appearance. We draw lines as 1pt
wide <code class="highlighter-rouge">UIView</code>s.</p>

<p>Now we just need to add these handles to the range selector in the annotation
manager. We add some ivars to keep hold of them:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@interface</span> <span class="nc">ShinobiRangeAnnotationManager</span> <span class="p">()</span><span class="o">&lt;</span><span class="n">UIGestureRecognizerDelegate</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">SChartAnnotation</span> <span class="o">*</span><span class="n">leftGripper</span><span class="p">,</span> <span class="o">*</span><span class="n">rightGripper</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@end</span></code></pre></figure>

<p>And then we can create instances of them and add them to the chart:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">createAnnotations</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">// Create the handles
</span>    <span class="n">leftGripper</span> <span class="o">=</span> <span class="p">[[</span><span class="n">ShinobiRangeHandleAnnotation</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithFrame</span><span class="p">:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span> <span class="nf">colour</span><span class="p">:[</span><span class="n">UIColor</span> <span class="nf">colorWithWhite</span><span class="p">:</span><span class="mi">0</span><span class="p">.</span><span class="mi">2</span> <span class="nf">alpha</span><span class="p">:</span><span class="mi">1</span><span class="p">.</span><span class="n">f</span><span class="p">]</span> <span class="n">xValue</span><span class="o">:</span><span class="n">chart</span><span class="p">.</span><span class="n">xAxis</span><span class="p">.</span><span class="n">axisRange</span><span class="p">.</span><span class="n">minimum</span> <span class="n">xAxis</span><span class="o">:</span><span class="n">chart</span><span class="p">.</span><span class="n">xAxis</span> <span class="n">yAxis</span><span class="o">:</span><span class="n">chart</span><span class="p">.</span><span class="n">yAxis</span><span class="p">];</span>
    <span class="n">rightGripper</span> <span class="o">=</span> <span class="p">[[</span><span class="n">ShinobiRangeHandleAnnotation</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithFrame</span><span class="p">:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span> <span class="nf">colour</span><span class="p">:[</span><span class="n">UIColor</span> <span class="nf">colorWithWhite</span><span class="p">:</span><span class="mi">0</span><span class="p">.</span><span class="mi">2</span> <span class="nf">alpha</span><span class="p">:</span><span class="mi">1</span><span class="p">.</span><span class="n">f</span><span class="p">]</span> <span class="n">xValue</span><span class="o">:</span><span class="n">chart</span><span class="p">.</span><span class="n">xAxis</span><span class="p">.</span><span class="n">axisRange</span><span class="p">.</span><span class="n">maximum</span> <span class="n">xAxis</span><span class="o">:</span><span class="n">chart</span><span class="p">.</span><span class="n">xAxis</span> <span class="n">yAxis</span><span class="o">:</span><span class="n">chart</span><span class="p">.</span><span class="n">yAxis</span><span class="p">];</span>

    <span class="p">...</span>
    <span class="c1">// Add the handles on top so they take gesture priority.
</span>    <span class="p">[</span><span class="n">chart</span> <span class="nf">addAnnotation</span><span class="p">:</span><span class="n">leftGripper</span><span class="p">];</span>
    <span class="p">[</span><span class="n">chart</span> <span class="nf">addAnnotation</span><span class="p">:</span><span class="n">rightGripper</span><span class="p">];</span>
<span class="p">}</span></code></pre></figure>

<p>And then, in the same way we added a gesture recogniser to the selected region
annotation, we can add one to each of the grippers:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">prepareGestureRecognisers</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">// And pan gesture recognisers for the 2 handles on the range selector
</span>    <span class="n">UIPanGestureRecognizer</span> <span class="o">*</span><span class="n">leftGripperRecogniser</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIPanGestureRecognizer</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithTarget</span><span class="p">:</span><span class="n">self</span> <span class="nf">action</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">handleGripperPan</span><span class="o">:</span><span class="p">)];</span>
    <span class="p">[</span><span class="n">leftGripper</span> <span class="nf">addGestureRecognizer</span><span class="p">:</span><span class="n">leftGripperRecogniser</span><span class="p">];</span>
    <span class="n">UIPanGestureRecognizer</span> <span class="o">*</span><span class="n">rightGripperRecogniser</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIPanGestureRecognizer</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithTarget</span><span class="p">:</span><span class="n">self</span> <span class="nf">action</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">handleGripperPan</span><span class="o">:</span><span class="p">)];</span>
    <span class="p">[</span><span class="n">rightGripper</span> <span class="nf">addGestureRecognizer</span><span class="p">:</span><span class="n">rightGripperRecogniser</span><span class="p">];</span>
<span class="p">}</span></code></pre></figure>

<p>We you can see we’ve added a new method to handle the dragging of the handles:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">handleGripperPan</span><span class="p">:(</span><span class="n">UIPanGestureRecognizer</span><span class="o">*</span><span class="p">)</span><span class="nv">recogniser</span>
<span class="p">{</span>
    <span class="n">CGPoint</span> <span class="n">currentTouchPoint</span> <span class="o">=</span> <span class="p">[</span><span class="n">recogniser</span> <span class="nf">locationInView</span><span class="p">:</span><span class="n">chart</span><span class="p">.</span><span class="n">canvas</span><span class="p">];</span>
    
    <span class="c1">// What's the new location we've dragged the handle to?
</span>    <span class="kt">double</span> <span class="n">newValue</span> <span class="o">=</span> <span class="p">[[</span><span class="n">chart</span><span class="p">.</span><span class="n">xAxis</span> <span class="nf">estimateDataValueForPixelValue</span><span class="p">:</span><span class="n">currentTouchPoint</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="nf">doubleValue</span><span class="p">];</span>
    
    <span class="n">SChartRange</span> <span class="o">*</span><span class="n">newRange</span><span class="p">;</span>
    <span class="c1">// Update the range with the new value according to which handle we dragged
</span>    <span class="k">if</span><span class="p">(</span><span class="n">recogniser</span><span class="p">.</span><span class="n">view</span> <span class="o">==</span> <span class="n">leftGripper</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Left handle =&gt; change the range minimum
</span>        <span class="n">newRange</span> <span class="o">=</span> <span class="p">[[</span><span class="n">SChartRange</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithMinimum</span><span class="p">:</span><span class="err">@</span><span class="p">(</span><span class="n">newValue</span><span class="p">)</span> <span class="nf">andMaximum</span><span class="p">:</span><span class="n">rightGripper</span><span class="p">.</span><span class="n">xValue</span><span class="p">];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// Right handle =&gt; change the range maximum
</span>        <span class="n">newRange</span> <span class="o">=</span> <span class="p">[[</span><span class="n">SChartRange</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithMinimum</span><span class="p">:</span><span class="n">leftGripper</span><span class="p">.</span><span class="n">xValue</span> <span class="nf">andMaximum</span><span class="p">:</span><span class="err">@</span><span class="p">(</span><span class="n">newValue</span><span class="p">)];</span>
    <span class="p">}</span>
    
    <span class="c1">// Move the selector
</span>    <span class="p">[</span><span class="n">self</span> <span class="nf">moveRangeSelectorToRange</span><span class="p">:</span><span class="n">newRange</span><span class="p">];</span>
    
    <span class="c1">// And fire the delegate method
</span>    <span class="p">[</span><span class="n">self</span> <span class="nf">callRangeDidMoveDelegateWithRange</span><span class="p">:</span><span class="n">newRange</span><span class="p">];</span>
<span class="p">}</span></code></pre></figure>

<p>This method does much the same as the <code class="highlighter-rouge">handlePan:</code> method we created for when
dragging the entire selector:</p>

<ul>
  <li>We find the current touch point and perform the same magic as before to
establish what data value this pixel value represents</li>
  <li>Then we decide which of our grippers we have moved, and from this create the
updated <code class="highlighter-rouge">SChartRange</code> we should be displaying.</li>
  <li>A call to the <code class="highlighter-rouge">moveRangeSelectorToRange:</code> method will ensure we move all the
annotations to the updated location. In this instance we’re actually asking it
to resize the selected region and one of the shaded regions, and to move one of
the lines and the grippers.</li>
  <li>Finally we need to make a call to the delegate method so that the main chart
can update itself as well.</li>
</ul>

<p>Because of the way we built up the manager, this process is actually pretty
simple - we’ve got methods to move the selector and inform the delegate.</p>

<h2 id="moving-on">Moving on</h2>
<p>We’ve now got a range selector which can update the main chart both by dragging
it, and by dragging the custom gripper annotations we’ve created at the end. This
is starting to get pretty good, but there are still some things we want to work
on. Firstly, it’s currently possible to drag the upper range selector gripper
to below the lower. This causes the main chart to start complaining that it
can’t display a range where the maximum is lower than the minimum. We’ll fix this
bug in the next post.</p>

<p>The other thing we’ll look at is adding momentum to the selector drag motion - 
this is something we come to expect from iOS controls, and you can see that it
works really well when you interact with the main chart. Currently however, when
you let go of the range selector it stops dead, so we will build a momentum
animation to improve the user experience.</p>

<p>You can read part III <a href="/blog/2013/01/19/building-a-range-selector-with-shinobi-charts-part-iii-adding-momentum">here</a>.</p>

<h3 id="update-20130310">Update 2013/03/10</h3>
<p>Edited the post to remove the use of internal methods from the ShinobiCharts
framework. This matches the updates to the codebase in the repository.</p>

	  ]]></description>
	</item>


</channel>
</rss>
