<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>iwantmyreal.name</title>
   
   <link>http://iwantmyreal.name</link>
   <description>so I can use google to index things I fixed and then promptly forgot</description>
   <language>en-uk</language>
   <managingEditor> Sam Davies</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Bringing dead projects back to life with Docker</title>
	  <link>/bringing-dead-projects-back-to-life-with-docker</link>
	  <author>Sam Davies</author>
	  <pubDate>2016-12-18T13:39:04+00:00</pubDate>
	  <guid>/bringing-dead-projects-back-to-life-with-docker</guid>
	  <description><![CDATA[
	     <p>This Saturday I found myself working on three separate ruby-on-rails projects. Three projects, with three different deployment strategies:</p>

<ol>
  <li>The project I’m currently working on is Rails 5, and we have a Docker-based development and deployment strategy. When a branch is merged into the <code class="highlighter-rouge">development</code> branch, Docker hub builds a new image, which we can then deploy to the staging server via slack. Getting this set up was a fair amount of up-front work, but now we’ve got the Docker file, it’s fairly easy to maintain.</li>
  <li>A project I started about 5 years ago that’s running happily on Heroku. This project was originally Rails 3.0, but I updated it to Rails 4.1 about a year ago. Since then I’ve not touched it much, but had to make a few small cosmetic changes this weekend. This was really easy to do with a Heroku deployment—I made the changes, deployed to staging to check they were OK, and then up to production. It would have been harder if I’d wanted to do spin up a local server, but the changes I made didn’t require it.</li>
  <li>An app I started about 4 years ago, and haven’t touched for nearly 3 years. This was written (and is still running) Rails 3.2, and uses Capistrano for deployment. All I wanted to do was update the mail server details. A three-line change. It took nearly 3 hours to complete.</li>
</ol>

<p>I’d like to write about why the third option was such hard work, compared to making changes in the first two, and how I used Docker to ease the process.</p>

<h1 id="the-problem">The Problem</h1>

<p>The codebase hadn’t been touched for three years. No dependency updates. No security patches. No updates to the version of Ruby.</p>

<p>This is a crappy way to make software. I don’t want to get into a discussion of this client, but rest-assured, I spent considerable energy trying to get across that you can’t just fire-and-forget with a web-app like this.</p>

<p>Needless to say, I lost those battles. Which is why it took me 3 hours to update 3 lines of code this weekend. It wasn’t even as if I had to find them. I knew exactly what to change. The challenge was getting them deployed.</p>

<p>This project is hosted on the client’s virtual host somewhere, so using Capistrano for deployment was a great option.</p>

<p>This’ll be fine though—I’ll grab the source, build the right Ruby version with <code class="highlighter-rouge">rbenv</code>, install dependencies with bundler and I’ll be done. Or not.</p>

<h1 id="installing-dependencies">Installing Dependencies</h1>

<p>I use macOS, so installing different versions of ruby is super-easy with <code class="highlighter-rouge">rbenv</code>:</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="gp">$ </span>rbenv install 1.9.3-p327</code></pre></figure>

<p>That went without a hitch, barring the warnings that this is really out-of-date and unsupported.</p>

<p>Then I can go ahead and install the dependencies. Since bundler creates a <code class="highlighter-rouge">Gemfile.lock</code>, you can be certain that precisely the same versions of your gems will install irrespective of when you last used them. Updating gems requires you to issues a specific update command.</p>

<p>That means that all you have to do is:</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="gp">$ </span>bundle install</code></pre></figure>

<p>Of course it didn’t work. When I last installed this specific gemset, Xcode still included a GCC buildchain. It was replaced with LLVM in 2013, which caused the native extensions for one of the gems not to compile.</p>

<blockquote>
  <p>Imagine an interlude here where I attempt installing just the gems I think I need, manually chasing the dependency chain. And then I spend a while reading through old stack overflow answers trying to find answers to problems that don’t say “update to this version”. I’m not going to write about it—you’ve all done it. You know how dull it is.</p>
</blockquote>

<p>I should point out at this stage that I didn’t really want to get into updating this project. Everything needed updating to much more recent versions, and I estimate it was at least a couple of days’ work. That is definitely not what the client wanted.</p>

<p>I realised I was about to jump headfirst into a rabbit hole much sooner than I usually do—at the point I was using homebrew versions to find old versions of dependencies I knew I should stop.</p>

<h1 id="docker-to-the-rescue">Docker to the rescue</h1>

<p>I’ve been doing a lot of work in Docker recently and have found the experience to be mostly very positive. It’s great for ensuring that we run the same stack in development, staging and production. That and the fact that we can be sure that we’re all running precisely the same versions of everything.</p>

<p>Although I didn’t need these features for my project revival, I realised that I could use Docker to create an image that reflected the exact dependencies I needed, irrespective of how old they were. And when I was done, I could just throw it away. I wouldn’t be randomly installing old crap into the host OS until I could get the app to deploy—it would all just be in a throwaway container. Perfect!</p>

<p>But wait.</p>

<p>What if, rather than building this image myself, <em>somebody had already done it for me?</em></p>

<p>DockerHub has official builds for a huge range of projects, one of which is Ruby. So if I can find an image that contains an old enough version of Ruby, I’ll be well on my way.</p>

<p><img src="/assets/201612/ruby_1.png" alt="Ruby versions on docker hub" /></p>

<p>It’s not in the supported list of versions, but the tag is there. That’ll do.</p>

<blockquote>
  <p>Note that I chose the full distro version here, because I wanted to be sure that everything required to build the native extensions was there. If I were deploying this in a Docker container, I’d look to choose a smaller base image.</p>
</blockquote>

<p>Now I can run up a shell in this container and check the install version of ruby:</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="gp">$ </span>Docker run -it ruby:1 bash
<span class="gp">root@b13634320876:/# </span>ruby --version
ruby 1.9.3p551 <span class="o">(</span>2014-11-13 revision 48407<span class="o">)</span> <span class="o">[</span>x86_64-linux]</code></pre></figure>

<p>OK—that version of Ruby will do just fine. I’ve now got a Docker container running with the correct version of ruby. But how can I get my app into it?</p>

<h1 id="mounting-a-local-directory">Mounting a local directory</h1>

<p>You can absolutely use Docker commands to mount a local directory inside the container. However, I’m a fan of Docker compose. This allows you to specify a system of containers and their dependencies in a declarative manner. This is done in a YAML file, and is really easy to understand.</p>

<p>Although this use case is very simple, it saves me having to remember Docker commands—instead relying on the <code class="highlighter-rouge">Docker-compose.yml</code> file to do the work:</p>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="s">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">2'</span>
<span class="s">services</span><span class="pi">:</span>
  <span class="s">app</span><span class="pi">:</span>
    <span class="s">image</span><span class="pi">:</span> <span class="s">ruby:1</span>
    <span class="s">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">.:/opt/webapp</span></code></pre></figure>

<p>This specifies a single service in compose. It uses the same image I just used, and mounts the current directory to the <code class="highlighter-rouge">/opt/webapp</code> point within the container.</p>

<p>Running this up is easy:</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="gp">$ </span>Docker-compose run app bash</code></pre></figure>

<p>Once in there I was able to navigate to the <code class="highlighter-rouge">/opt/webapp</code> directory and <code class="highlighter-rouge">bundle install</code> all the dependencies.</p>

<p>The great thing about mounting the directory in this manner, is that you can continue to edit your files in the host OS, including doing git operations etc.</p>

<p>This is the approach we’re using for the app we’re working on at the moment. It has some downsides, but on the whole, it’s a great way to develop locally.</p>

<h1 id="so-what">So what?</h1>

<p>What was the point of this post? I wanted to highlight a slightly different use for Docker. There’s a huge focus on building these massively scalable, self-healing infrastructures. Sure they sound sexy, but I don’t think all that many of us need those features.</p>

<p>But that doesn’t mean that you shouldn’t take a look at what Docker, or other containerisation technologies, have to offer. This example of getting a dead app back up on its feet long enough to patch some settings on a live app is a perfect demonstration of what else you can do.</p>

<p>Hopefully you’ll see another side to Docker too.</p>


	  ]]></description>
	</item>

	<item>
	  <title>Not all env variables are born equal</title>
	  <link>/not-all-env-vars-are-born-equal</link>
	  <author>Sam Davies</author>
	  <pubDate>2016-12-11T09:05:04+00:00</pubDate>
	  <guid>/not-all-env-vars-are-born-equal</guid>
	  <description><![CDATA[
	     <h3 id="or-how-i-found-solved-my-rails-problem-trawling-through-linux-source-code"><em>or how I found solved my rails problem trawling through linux source code</em></h3>

<p>Whilst building the latest web application in the raywenderlich.com web empire, I stumbled across a problem I expected was a simple error on my part. It wouldn’t take long to track down and fix. Oh, the naïvety of  the pre-debugging ignorance.</p>

<p>Codenamed <em>kerching</em>, the app in question is a relatively small ruby-on-rails app, running on <a href="https://aws.amazon.com/">AWS</a> in three separate docker containers. Maybe I’ll write about the dockerisation architecture one day—it’s probably sufficiently interesting—but the focus of this post is on just one of those containers—the worker.</p>

<p>The worker container is responsible for running all kinds of background jobs, and uses AWS’s Simple Queue Service (SQS) for task queuing via the <a href="https://github.com/phstc/shoryuken">shoryuken</a> gem (probably worthy of another post). As such, it requires full access to the rails stack, and in practice is actually running the same docker image as the app container. In addition to running jobs, it also schedules them via cron jobs, assisted by the <a href="https://github.com/javan/whenever">whenever</a> gem.</p>

<p>With me so  far? Don’t worry—I’ve nearly finished setting the scene.</p>

<p>The cron jobs are incredibly simple—they just request a particular <a href="http://guides.rubyonrails.org/active_job_basics.html">ActiveJob</a> to run. This then gets chucked onto the SQS queue, and handled by the primary worker process. To some extent, this is working around a limitation of SQS, but that’s not important right now.</p>

<p>This means that both the worker process (shoryuken) and the cron jobs have to fire up the rails stack. But that’s fine—the container is based on the app image so it’ll all be gravy. Won’t it?</p>

<h2 id="enter-environment-variables-stage-right">Enter environment variables stage right</h2>
<p>I promised you something about environment variables. You’ve been forced to read (well, let’s face it, skim) a lot of text, and I haven’t even mentioned them. What are they all about?</p>

<p>When building  web apps, especially those that are built into docker containers, you don’t want to include any secrets in source code. Therefore a popular (and potentially “best”) practice is to provide them via environment variables. Docker supports this—allowing you to easily inject variables into a container at runtime via an env file.</p>

<p>We use this a lot in our development, staging and production stacks—allowing us to use an identical container image for all three environments, but connecting to different infrastructure, with different configurations in each instance.</p>

<h2 id="a-problem-surfaces">A problem surfaces</h2>
<p>You finally have enough background to understand the first problem: the cron jobs were unable to load the rails stack.</p>

<p>Remember that the cron job needs to load the rails stack to schedule a background job? And that the rails stack is configured almost exclusively via environment variables? And that docker injects the environment variables at runtime?</p>

<p>Well, environment variables are only available to the process that docker starts. If that’s a shell (like bash) then that has access to the variables you define outside docker, but any other process has no such knowledge.</p>

<p>This is the case for cron. It runs as a background service, and so doesn’t get provided the environment variables injected by docker. However, it does load a list of environment variables before it starts—from the <code class="highlighter-rouge">/etc/environment</code> file.</p>

<p>Therefore as part of the startup process for the worker, we populate this file with a copy of the current environment:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># Make a copy of the environment variables</span>
env &gt; /etc/environment

<span class="c"># Start the cron service</span>
service cron start

<span class="c"># Start the shoryuken worker process </span>
bundle <span class="nb">exec </span>shoryuken -C config/shoryuken.yml --rails</code></pre></figure>

<p>Now, when the cron job starts, it reads the contents of the <code class="highlighter-rouge">/etc/environment</code> file and has access to all the environment variables it needs. Super.</p>

<h2 id="and-thats-the-end-of-the-story">and that’s the end of the story</h2>
<p>Balls is it.</p>

<p>This worked splendidly for a while in staging. But on a recent deploy, we started getting notifications that the worker process was no longer, well, working. On investigation I discovered that the job worker was fine, but that the cron jobs were no longer firing.</p>

<p>So began a process of trying to debug cron.</p>

<p>First I needed to find where the hell stuff was logged. Turns out, it wasn’t.</p>

<p>In my minimal docker image (based on Debian jessie), I had neither a mail transport agent, nor a system logging framework. That meant that the two possible places cron would be sending error logs didn’t exist.</p>

<p>Adding <code class="highlighter-rouge">rsyslog</code> to the docker image was pretty easy—it’s just a new package to install at build time. I could then see that the cron job was running at the correct time in <code class="highlighter-rouge">/var/log/syslog</code>, although still not the errors. But I still couldn’t see the output of the cron job itself:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Dec 11 03:47:01 7d0126f97a33 CRON[552]: (root) CMD (echo "HELLO FROM CRON")
</code></pre>
</div>

<p>Adding <code class="highlighter-rouge">&gt; /var/log/cron.log 2&gt;&amp;1</code> to the end of the command in the cron tab means that error and standard output will all be piped into a new file, which was helpful for debugging, but not standard practice for docker:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>HELLO FROM CRON
</code></pre>
</div>

<h2 id="aside-logging-in-docker">aside: logging in docker</h2>

<p>It’s standard practice within docker containers to log everything to standard out. That way the logging is picked up by docker and can be piped to a multitude of services. In our stack, we pipe all docker logs to AWS CloudWatch, providing a single location for logs for our entire infrastructure.</p>

<p>Both rsyslog and our cron tasks are now logging to files—how can I get them to standard out?</p>

<p>Well, first the cron job itself.</p>

<p>You might think using <code class="highlighter-rouge">&gt; /dev/stdout 2&gt;&amp;1</code> would do the trick. But you’d be both unnecessarily verbose and incorrect. But uou wouldn’t be alone. That’s precisely what I thought would work.</p>

<p>It doesn’t.</p>

<p>Why doesn’t it work? Well, <code class="highlighter-rouge">/dev/stdout</code> is linked to the standard out <em>of the current process</em>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>0 lrwxrwxrwx 1 root root     15 Dec 11 02:29 stderr -&gt; /proc/self/fd/2
0 lrwxrwxrwx 1 root root     15 Dec 11 02:29 stdin -&gt; /proc/self/fd/0
0 lrwxrwxrwx 1 root root     15 Dec 11 02:29 stdout -&gt; /proc/self/fd/1
</code></pre>
</div>

<p>We only see (and hence docker only logs) the stdout of the launch process. Cron runs jobs in a different process, and hence their stdout gets lost in the ether (or emailed to you if you have an MTA) configured.</p>

<p>To get to the stdout of the launch process, you need <code class="highlighter-rouge">/proc/1/fd/1</code>. The first <code class="highlighter-rouge">1</code> refers to the PID of the process. Provided you haven’t told docker to do anything different (like specified it launches using the host PIDs) then the process it launches will have a PID of <code class="highlighter-rouge">1</code>.</p>

<p>The second <code class="highlighter-rouge">1</code> refers to stdout. <code class="highlighter-rouge">0</code> would be stdin and <code class="highlighter-rouge">2</code> is stderr/.</p>

<p>That means updating the cron command to the following will log out as expected:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>* * * * * echo "HELLO FROM CRON" &gt;&gt; /proc/1/fd/1 2&gt;&amp;1
</code></pre>
</div>

<p>We use exactly the same principle for syslog too, this time creating a symlink between the file output and this stdout:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ ln -sf /proc/1/fd/1 /var/log/syslog
</code></pre>
</div>

<p>Now the output from both the cron daemon and the jobs themselves gets piped directly to the stdout of the primary process of the container. The can be a little distracting whilst working in the container, but it means everything will be logged by docker.</p>

<h2 id="back-on-track-the-environment-is-broken">Back on track: the environment is broken</h2>

<p>Now we can see the output from the cron job, we can have a crack at fixing it.</p>

<p>The output is from a component we use to sign CloudFront URLs. This uses OpenSSL to sign using RSA, and therefore requires a public key. The error suggests that this key is malformed:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>/usr/local/bundle/gems/cloudfront-signer-3.0.0/lib/cloudfront-signer.rb:54:in `initialize': Neither PUB key nor PRIV key: nested asn1 error (OpenSSL::PKey::RSAError)
  from /usr/local/bundle/gems/cloudfront-signer-3.0.0/lib/cloudfront-signer.rb:54:in `new'
  from /usr/local/bundle/gems/cloudfront-signer-3.0.0/lib/cloudfront-signer.rb:54:in `key='
  from /var/www/kerching/config/initializers/cloudfront_signer.rb:5:in `block in &lt;top (required)&gt;'
</code></pre>
</div>

<p>But how can that be? The key is provided by an environment variable, and the worker process has no such problem.</p>

<p>I can see the correct key in <code class="highlighter-rouge">/etc/environment</code>, which is where the cron job gets its environment variables, so what’s going on?</p>

<p>Adding some logging to the rails initialiser shows that the key variable is being truncated.</p>

<p>A check to see that the cron job does indeed have access to the <code class="highlighter-rouge">/etc/environment</code> file, adding the following cron job:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>* * * * * cat /etc/environment &gt; /proc/1/fd/1 2&gt;&amp;1
</code></pre>
</div>

<p>This yields the following results:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>HOSTNAME=9017b7e8da1a
TERM=xterm
MY_KEY=01........|.........|.........|.........|.........02........|.........|.........|.........|.........03........|.........|.........|.........|.........04........|.........|.........|.........|.........05........|.........|.........|.........|.........06........|.........|.........|.........|.........07........|.........|.........|.........|.........08........|.........|.........|.........|.........09........|.........|.........|.........|.........10........|.........|.........|.........|.........11........|.........|.........|.........|.........12........|.........|.........|.........|.........13........|.........|.........|.........|.........14........|.........|.........|.........|.........15........|.........|.........|.........|.........16........|.........|.........|.........|.........17........|.........|.........|.........|.........18........|.........|.........|.........|.........19........|.........|.........|.........|.........20........|.........|.........|.........|.........21........|.........|.........|.........|.........22........|.........|.........|.........|.........23........|.........|.........|.........|.........24........|.........|.........|.........|.........25........|.........|.........|.........|.........26........|.........|.........|.........|.........27........|.........|.........|.........|.........28........|.........|.........|.........|.........29........|.........|.........|.........|.........30........|.........|.........|.........|.........
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
PWD=/
SHLVL=1
HOME=/root
no_proxy=*.local, 169.254/16
_=/usr/bin/env
</code></pre>
</div>

<p>Yep. So what about the loaded environment, with:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>* * * * * env &gt; /proc/1/fd/1 2&gt;&amp;1
</code></pre>
</div>

<p>Well, that produces the following:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>no_proxy=*.local, 169.254/16
HOSTNAME=9017b7e8da1a
SHLVL=1
HOME=/root
MY_KEY=01........|.........|.........|.........|.........02........|.........|.........|.........|.........03........|.........|.........|.........|.........04........|.........|.........|.........|.........05........|.........|.........|.........|.........06........|.........|.........|.........|.........07........|.........|.........|.........|.........08........|.........|.........|.........|.........09........|.........|.........|.........|.........10........|.........|.........|.........|.........11........|.........|.........|.........|.........12........|.........|.........|.........|.........13........|.........|.........|.........|.........14........|.........|.........|.........|.........15........|.........|.........|.........|.........16........|.........|.........|.........|.........17........|.........|.........|.........|.........18........|.........|.........|.........|.........19........|.........|.........|.........|.........20........|.........|.........|.........|.........21........|.....
LOGNAME=root
_=/usr/bin/env
TERM=xterm
PATH=/usr/bin:/bin
SHELL=/bin/sh
PWD=/root
</code></pre>
</div>

<p>Aha—<code class="highlighter-rouge">MY_KEY</code> seems to stop just after <code class="highlighter-rouge">21</code>, instead of continuing to past <code class="highlighter-rouge">30</code>. The private key is being truncated, which explains why it is now malformed.</p>

<p>But why?</p>

<blockquote>
  <p><strong>Note:</strong> We’re now into the depths of Linux and my knowledge is somewhat patchy. Please feel free to correct my mistakes and I’ll update this post.</p>
</blockquote>

<p>Pluggable Authentication Modules (<a href="http://www.linux-pam.org">PAM</a>) is  mechanism within Linux whose responsibility is authentication. Part of its remit includes preparing the environment for different processes. Services have their environment configured as per the <strong>pam_env</strong> module, with the configuration appearing in the <code class="highlighter-rouge">/etc/pam.d</code> directory.</p>

<p>The cron file within there shows that it should be loading the environment from the <code class="highlighter-rouge">/etc/environment</code> file as expected:</p>

<div class="highlighter-rouge"><pre class="highlight"><code># The PAM configuration file for the cron daemon

@include common-auth

# Sets the loginuid process attribute
session    required     pam_loginuid.so

# Read environment variables from pam_env's default files, /etc/environment
# and /etc/security/pam_env.conf.
session       required   pam_env.so

# In addition, read system locale information
session       required   pam_env.so envfile=/etc/default/locale
</code></pre>
</div>

<p>That narrows it down then—something about this <strong>pam_env</strong> module appears to be truncating the environment variables it imports.</p>

<h2 id="off-we-trundle-into-c">Off we trundle into C</h2>
<p>Knowing this wasn’t enough for me. I wanted to confirm that my suspicions were correct, and to find exactly <em>why</em> it is being truncated. For that I needed to take a trip off into the PAM source code.</p>

<blockquote>
  <p>That’ll never work.</p>
</blockquote>

<p>The <strong>pam_env</strong> part of <a href="https://git.fedorahosted.org/cgit/linux-pam.git/tree/libpam/pam_env.c">libpam</a> itself details how environment variables are set, parsed, returned and stored. But nothing about reading them from a file.</p>

<p>For that we need to look at the <strong>pam_env</strong> <a href="https://git.fedorahosted.org/cgit/linux-pam.git/tree/modules/pam_env/pam_env.c">module</a>.</p>

<p>Within here there is a function whose job it is to read env variables from a file. Perfect.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">int</span>
<span class="nf">_parse_config_file</span><span class="p">(</span><span class="n">pam_handle_t</span> <span class="o">*</span><span class="n">pamh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ctrl</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">conf</span><span class="p">;</span>
    <span class="n">VAR</span> <span class="n">Var</span><span class="p">,</span> <span class="o">*</span><span class="n">var</span><span class="o">=&amp;</span><span class="n">Var</span><span class="p">;</span>

    <span class="n">D</span><span class="p">((</span><span class="s">"Called."</span><span class="p">));</span>

    <span class="n">var</span><span class="o">-&gt;</span><span class="n">name</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">defval</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">override</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>

    <span class="n">D</span><span class="p">((</span><span class="s">"Config file name is: %s"</span><span class="p">,</span> <span class="n">file</span><span class="p">));</span>

    <span class="cm">/*
     * Lets try to open the config file, parse it and process
     * any variables found.
     */</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">conf</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="s">"r"</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">pam_syslog</span><span class="p">(</span><span class="n">pamh</span><span class="p">,</span> <span class="n">LOG_ERR</span><span class="p">,</span> <span class="s">"Unable to open config file: %s: %m"</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">PAM_IGNORE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* _pam_assemble_line will provide a complete line from the config file,
     * with all comments removed and any escaped newlines fixed up
     */</span>

    <span class="k">while</span> <span class="p">((</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">_assemble_line</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">D</span><span class="p">((</span><span class="s">"Read line: %s"</span><span class="p">,</span> <span class="n">buffer</span><span class="p">));</span>
<span class="p">...</span></code></pre></figure>

<p>This isn’t overly complicated C code, in fact the problem is in the short snippet above.</p>

<p>In C, you’re responsible for all the memory management—including allocating the correct amount of space to read a line from a file in. That’s exactly what’s happening here: a buffer is allocated, and then populated using the <code class="highlighter-rouge">_assemble_line</code> function.</p>

<p>The buffer is defined right at the top of the above snippet:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span></code></pre></figure>

<p>It has a size of MAX_BUFFER characters long. Which means that’s the maximum length line that can be read from an environment file.</p>

<p>Definitely getting somewhere now—”but what’s that value?” I hear you ask. Well it’s defined as a constant on line 55 of this file:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define BUF_SIZE 1024</span></code></pre></figure>

<p>And finally I’ve reached the nub of the problem: although environment variables can be pretty much any size (I think they’re limited by memory constraints), the longest line that can be read from <code class="highlighter-rouge">/etc/environment</code> is 1024 characters.</p>

<p>Our private key is 1700 characters.</p>

<p>That’ll never work.</p>

<h2 id="solution">Solution</h2>

<blockquote>
  <p>has the advantage that it’ll, ya know, actually work.</p>
</blockquote>

<p>My solution to this problem is probably a little unsatisfying: we don’t actually need that environment variable for the cron job. The cron job will never be asked to sign a URL. Therefore I can rescue the exception and continue on with my day.</p>

<p>But what if I actually <em>needed</em> that key.  Well, here’s a couple of options:</p>

<ol>
  <li>Split the env var up into 2, and then rejoin them in code. The length of the entire line (including variable name) has to be less than 1024, but you could conceivably split your variables up into pieces and reassemble them later. To an extent, we already do this to cope with newlines in the private key, which the docker env injection doesn’t cope with. However, this feels pretty unsatisfactory.</li>
  <li>Store the environment variables somewhere else. You could create a script that exports each of them in turn, and then run that before any cron job:</li>
</ol>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">set</span> -a
<span class="nb">export </span><span class="nv">MYLONGVAR</span><span class="o">=</span><span class="s2">"hello"</span></code></pre></figure>

<p>This is a bit more fiddly to write as you can’t just use the output from <code class="highlighter-rouge">env</code>,  but it’s not that difficult, and has the advantage that it’ll, ya know, actually work.</p>

<h2 id="and-im-done">and I’m done</h2>

<p>It’s been a while since I wrote a post on here, and there have been lots of things that have made me think “that’d make a good post”.</p>

<p>This is the first of those that have actually taken form. A lot of the work I’ve been doing lately is in a similar space. If you’re interested in reading more about docker, rails, Linux, AWS etc then let me know on Twitter. Otherwise this might be a short lived reanimation.</p>

<p>sam</p>

	  ]]></description>
	</item>


</channel>
</rss>
