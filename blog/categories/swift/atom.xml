<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | iwantmyreal.name]]></title>
  <link href="http://iwantmyreal.name/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://iwantmyreal.name/"/>
  <updated>2015-04-04T22:19:36+01:00</updated>
  <id>http://iwantmyreal.name/</id>
  <author>
    <name><![CDATA[Sam Davies]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ReactiveCocoa 2.x with Swift]]></title>
    <link href="http://iwantmyreal.name/blog/2014/07/02/reactivecocoa-2-dot-x-with-swift/"/>
    <updated>2014-07-02T09:57:10+01:00</updated>
    <id>http://iwantmyreal.name/blog/2014/07/02/reactivecocoa-2-dot-x-with-swift</id>
    <content type="html"><![CDATA[<p>I recently wrote a blog post on the ShinobiControls blog about using
ReactiveCocoa with a ShinobiChart. It’s great - you should go and
<a href="http://www.shinobicontrols.com/blog/posts/2014/06/24/reactiveshinobi-using-shinobicharts-with-reactivecocoa">read it</a>.
I was also invited to give a talk at <a href="http://briste.ch/">#bristech</a> around the
same time, and thought that this blog post would make a really interesting topic.
The audience at #bristech is not an iOS audience. Not even mobile-focused. It’s
very much a mixed discipline event, with a heavy focus on javascript (lowest
common denominator etc.). Therefore I decided a general talk on functional
reactive programming, with ReactiveCocoa examples would be a great place to go.</p>

<p>One of the things non-Cocoa developers complain about is the somewhat alien
appearance of objective-C. Now, I don’t really think this is a valid complaint,
but in the interests of making my talk more accessible, I decided that if the
examples I gave were in Swift then fewer people would be frightened off.</p>

<p>And so begins the great-swiftening. I took the original project which accompanied
the previous blog post, and swiftified it. There were a few things I thought
might be useful to share. This post is the combination of those thoughts.</p>

<!--more-->

<h1 id="bridging-headers">Bridging Headers</h1>

<p>Bridging headers are part of the machinery which enables interaction between
swift and objective-C. They’re well-documented as part of Apple’s
<a href="https://developer.apple.com/library/prerelease/mac/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_75">interoperability guide</a>.
Essentially, there is a special header inside your project (specified with a
build setting) into which the objective-C headers for the classes you wish to use
with Swift should be collected.</p>

<p>The <strong>ReactiveWikiMonitor</strong> project uses 3 objective-C libraries:</p>

<ul>
  <li>ShinobiCharts</li>
  <li>SocketRocket</li>
  <li>ReactiveCocoa</li>
</ul>

<p>Therefore, the bridging header looks like this:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;ShinobiCharts/ShinobiChart.h&gt;
</span><span class='line'>#import &lt;SocketRocket/SRWebSocket.h&gt;
</span><span class='line'>#import &lt;ReactiveCocoa/ReactiveCocoa.h&gt;</span></code></pre></td></tr></table></div></figure></p>

<p>It’s actually that easy! I love how simple interoperability is at this level.
However, if you try and compile this (with your Podfile created correctly and
pods installed) then you’ll run in to some problems within the ReactiveCocoa
source.</p>

<h1 id="compiling-reactivecocoa-in-a-swift-project">Compiling ReactiveCocoa in a Swift Project</h1>

<p>If you try to build a project now, then the compiler will first attempt to compile
your pods - including ReactiveCocoa. Do it. You’ll see that it doesn’t work - you
get a compiler error around the methods <code>and</code>, <code>or</code> and <code>not</code> on <code>RACSignal+Operations</code>.
This is because of a compiler bug, which will hopefully be fixed in a future
release, but until then we can work around it by renaming those methods in the
ReactiveCocoa source.</p>

<p>Find the <strong>RACSignal+Operations.h</strong> file in the CocoaPods project, and rename
the aforementioned methods to <code>rac_and</code>, <code>rac_or</code> &amp; <code>rac_not</code>. You’ll have to
repeat this in the related implementation (<code>.m</code>) file as well. You can then find
all the places that use these methods, by attempting a build (there are only about
three places in the RAC source). Fixing each call by changing its name will work.
Note that it might also be possible to do this using Xcode’s refactor tools, but
I’ve not had the most success in the past.</p>

<p>Now your project will build, yay!</p>

<h1 id="using-generics-to-improve-syntax">Using generics to improve syntax</h1>

<p>One of the things I like about objective-C is the implicit casting available in
the arguments to blocks. By this I mean the following is the signature for a map
function in RAC (defined on <code>RACStream</code>):</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (instancetype)map:(id (^)(id value))block;</span></code></pre></td></tr></table></div></figure></p>

<p>Which means that when creating a map stage in your pipeline, it would look like
this:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>map:^id(id *value) {
</span><span class='line'>     return value[@”content”];
</span><span class='line'> }]</span></code></pre></td></tr></table></div></figure></p>

<p>The block returns an <code>id</code>, and takes an <code>id</code> for the value parameter. This is so
that in objective-C you can build a functional pipeline which can process any
datatypes (since generics don’t exist). However, the syntax allows you to specify
(and therefore implicitly cast) these parameters, by defining your block like
this:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>map:^NSString*(NSDictionary *value) {
</span><span class='line'>     return value[@”content”];
</span><span class='line'> }]</span></code></pre></td></tr></table></div></figure></p>

<p>Although not strictly necessary (since the compiler will allow you to call any
methods on an <code>id</code>), it just allows you to have additional type checking at
compile (and writing) time.</p>

<p>And now we move our attention to the world of Swift. The Swift equivalent to <code>id</code>
is <code>AnyObject</code>, so the map function now looks like this:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.map({ (value: AnyObject!) -&gt; AnyObject in
</span><span class='line'>  return value[“content”]
</span><span class='line'>})</span></code></pre></td></tr></table></div></figure></p>

<p>If you attempt to build this code then (as of beta2) the compiler will crash.
In order to make this work you might think that the following would work:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.map({ (value: NSDictionary!) -&gt; NSString in
</span><span class='line'>  return value[“content”]
</span><span class='line'>})</span></code></pre></td></tr></table></div></figure></p>

<p>However, Swift’s type system doesn’t like this (with a somewhat cryptic and
misplaced error message). Therefore you need to explicitly cast:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.map({ (value: AnyObject!) -&gt; AnyObject in
</span><span class='line'>  if let dict = value as? NSDictionary {
</span><span class='line'>    return dict[“content”]
</span><span class='line'>  }
</span><span class='line'>  return “”
</span><span class='line'>})</span></code></pre></td></tr></table></div></figure></p>

<p>You have to do this every time you want to call a <code>map</code> function, which in my
opinion is a little bit clumsy.</p>

<p>Which brings us to Swift’s generic system, and type inference.</p>

<h3 id="a-generic-version-of-map">A generic version of <code>map</code></h3>

<p>The syntax I’d like to use is:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.mapAs({ (dict: NSDictionary) -&gt; NSString in
</span><span class='line'>  return dict[“content”] as NSString
</span><span class='line'>})</span></code></pre></td></tr></table></div></figure></p>

<p>So how do we go about building this <code>mapAs()</code> extension method. Well, extending
a class in Swift is easy:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension RACStream {
</span><span class='line'>  func myNewMethod() {
</span><span class='line'>      println(“My new method”)
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></p>

<p>We’re going to create a generic <code>mapAs()</code> method, which includes the explicit
downcasting and the call to the underlying <code>map()</code> method:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func mapAs&lt;T,U: AnyObject&gt;(block: (T) -&gt; U) -&gt; Self {
</span><span class='line'>  return map({(value: AnyObject!) in
</span><span class='line'>    if let casted = value as? T {
</span><span class='line'>      return block(casted)
</span><span class='line'>    }
</span><span class='line'>    return nil
</span><span class='line'>  })
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></p>

<p>This specifies that the <code>mapAs</code> method has 2 generic params - the input and output,
and that there is a requirement that the output be of type <code>AnyObject</code>. The closure
we pass to the <code>mapAs()</code> method takes the first generic type and returns the second.</p>

<p>All the <code>mapAs()</code> method does is call the underlying <code>map()</code> method, but performs
the downcasting as appropriate.</p>

<p>We can write a similar method for filter:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func filterAs&lt;t>(block: (T) -&gt; Bool) -&gt; Self {
</span><span class='line'>  return filter({(value: AnyObject!) in
</span><span class='line'>    if let casted = value as? T {
</span><span class='line'>      return block(casted)
</span><span class='line'>    }
</span><span class='line'>    return false
</span><span class='line'>  })
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></t></p>

<p>This obviously can be extended to all the methods on <code>RACStream</code>, <code>RACSignal</code> etc.</p>

<p>I find that using these generic methods (combined with Swift’s type inference),
leads to a much more expressive pipeline:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>wsConnector.messages
</span><span class='line'>  .filterAs({ (dict: NSDictionary) in
</span><span class='line'>      return (dict[“type”] as NSString).isEqualToString(“unspecified”)
</span><span class='line'>    })
</span><span class='line'>  .mapAs({ (dict: NSDictionary) -&gt; NSString in
</span><span class='line'>    return dict[“content”] as NSString
</span><span class='line'>    })
</span><span class='line'>  .deliverOn(RACScheduler.mainThreadScheduler())
</span><span class='line'>  .subscribeNextAs({(value: NSString) in
</span><span class='line'>    self.tickerLabel.text = value
</span><span class='line'>    })</span></code></pre></td></tr></table></div></figure></p>

<h1 id="conclusion">Conclusion</h1>

<p>This is very much an interim piece of work. We can expect RAC3 to be swift-focused,
and so these techniques won’t be required. However, they don’t just apply to RAC.
Using generics to simplify block arguments is especially helpful when interfacing
with objective-C which uses <code>id</code> as a type.</p>

<p>As ever, the code for this is available on the ‘swiftify’ branch of the
ReactiveShinobi project on my <a href="https://github.com/sammyd/ReactiveShinobi/tree/swiftify">github</a>.
If you don’t fancy having to fiddle with the ReactiveCocoa source once you’ve
pulled it down, there’s also a <a href="https://github.com/sammyd/ReactiveShinobi/tree/swiftify_with_pods">swiftify_with_pods</a>
branch, which includes the source code changes.</p>

<p>sam</p>
]]></content>
  </entry>
  
</feed>
